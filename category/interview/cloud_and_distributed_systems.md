---
layout: default
title: "Cloud & Distributed Systems Interview — 완벽 가이드"
---

<p class="breadcrumb"><a href="/cs_study/home.html">🏠 홈으로</a></p>

<section>
  <h2>클라우드 & 분산 시스템 면접 대비 — 기본·심화 Q&A + 추가 예상 질문 + 개념 요약</h2>
  <p>구성: 기본 면접 Q&A → 심화 면접 Q&A → 추가 예상 질문 Q&A → 클라우드 & 분산 시스템 개념 요약 노트</p>
</section>

<!-- ① 기본 면접 Q&A -->
<details open>
  <summary><span class="accordion-title">📋 기본 면접 Q&amp;A</span> <span class="indicator">펼치기</span></summary>
  <div class="accordion-content">
<details>
  <summary style="font-size:1rem;"><b>Q1. 클라우드 컴퓨팅의 서비스 모델(IaaS, PaaS, SaaS)을 설명하고 각각의 특징과 예시를 들어주세요.</b></summary>
  <div class="accordion-content">
<p>클라우드 컴퓨팅은 인터넷을 통해 컴퓨팅 리소스를 제공하는 모델로 세 가지 주요 서비스 유형이 있습니다. IaaS(Infrastructure as a Service)는 가상화된 컴퓨팅 인프라를 제공하는 서비스로, 사용자가 가상 머신, 스토리지, 네트워크를 필요에 따라 프로비저닝할 수 있습니다. AWS EC2, Google Compute Engine, Azure Virtual Machines가 대표적이며, 운영체제부터 애플리케이션까지 사용자가 직접 관리해야 합니다. PaaS(Platform as a Service)는 애플리케이션 개발과 배포를 위한 플랫폼을 제공하는 서비스로, 개발자는 코드에만 집중하고 인프라 관리는 제공자가 담당합니다. AWS Elastic Beanstalk, Google App Engine, Heroku가 예시이며, 빠른 개발과 배포가 가능하지만 플랫폼 제약이 있습니다. SaaS(Software as a Service)는 완성된 소프트웨어를 웹 브라우저를 통해 제공하는 서비스로, Gmail, Office 365, Salesforce가 대표적입니다. 사용자는 별도 설치나 관리 없이 즉시 사용할 수 있지만 커스터마이징에 제한이 있습니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q2. 분산 시스템의 정의와 분산 시스템을 사용하는 이유, 주요 도전과제를 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>분산 시스템은 네트워크로 연결된 여러 독립적인 컴퓨터가 하나의 일관된 시스템처럼 동작하는 시스템입니다. 사용자에게는 단일 시스템처럼 보이지만 실제로는 여러 노드가 협력하여 작업을 수행합니다. 분산 시스템을 사용하는 주요 이유는 확장성으로, 수직적 확장의 한계를 극복하고 수평적으로 노드를 추가하여 처리 능력을 증가시킬 수 있습니다. 가용성 향상을 위해 단일 장애점을 제거하고 일부 노드가 실패해도 서비스가 계속 동작하도록 합니다. 지리적 분산을 통해 전 세계 사용자에게 낮은 지연시간으로 서비스를 제공할 수 있습니다. 하지만 주요 도전과제도 있습니다. 네트워크 지연과 파티션으로 인한 통신 문제, 노드 간 시계 동기화 어려움, 분산 상태 관리의 복잡성, 부분적 실패 처리의 어려움, 일관성과 성능 간의 트레이드오프 등이 있습니다. 또한 디버깅과 모니터링이 복잡해지고, 보안 공격 표면이 증가하는 문제도 있습니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q3. CAP 정리를 설명하고 CP 시스템과 AP 시스템의 예시를 들어주세요.</b></summary>
  <div class="accordion-content">
<p>CAP 정리는 분산 시스템에서 일관성(Consistency), 가용성(Availability), 분할 내성(Partition tolerance) 중 최대 두 가지만 동시에 보장할 수 있다는 이론입니다. 일관성은 모든 노드가 동시에 같은 데이터를 보는 것이고, 가용성은 시스템이 항상 응답하는 것이며, 분할 내성은 네트워크 분할 상황에서도 시스템이 동작하는 것입니다. 네트워크 분할은 분산 시스템에서 불가피하게 발생하므로, 실제로는 일관성과 가용성 중 하나를 선택해야 합니다. CP 시스템은 일관성과 분할 내성을 보장하는 대신 가용성을 포기하는 시스템입니다. MongoDB, Redis Cluster, Apache HBase가 예시로, 네트워크 분할 시 일부 노드가 응답하지 않을 수 있지만 데이터 일관성을 보장합니다. 금융 거래나 재고 관리 같이 정확성이 중요한 시스템에 적합합니다. AP 시스템은 가용성과 분할 내성을 보장하는 대신 일관성을 포기하는 시스템입니다. Amazon DynamoDB, Apache Cassandra, CouchDB가 예시로, 항상 응답하지만 노드 간 데이터가 일시적으로 다를 수 있습니다. 소셜 미디어나 추천 시스템 같이 가용성이 중요한 서비스에 적합합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q4. 마이크로서비스 아키텍처의 장단점과 모놀리식 아키텍처와의 차이점을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>마이크로서비스 아키텍처는 애플리케이션을 작은 독립적인 서비스들로 분해하는 아키텍처 패턴입니다. 각 서비스는 특정 비즈니스 기능을 담당하고, 독립적으로 개발, 배포, 확장할 수 있습니다. 주요 장점으로는 기술 다양성으로 각 서비스에 최적의 기술 스택을 선택할 수 있고, 독립적 배포로 다른 서비스에 영향 없이 업데이트가 가능합니다. 장애 격리를 통해 한 서비스의 실패가 전체 시스템에 미치는 영향을 제한하고, 팀 자율성을 통해 작은 팀이 서비스를 소유하고 관리할 수 있습니다. 하지만 단점도 있습니다. 분산 시스템의 복잡성으로 네트워크 지연, 부분 실패, 데이터 일관성 문제가 발생하고, 운영 복잡성이 증가하여 모니터링, 로깅, 배포가 어려워집니다. 데이터 관리가 복잡해지고 서비스 간 트랜잭션 처리가 어려우며, 초기 개발 비용이 높습니다. 모놀리식 아키텍처는 모든 기능이 하나의 배포 단위로 구성되어 개발과 배포가 단순하지만, 확장성과 기술 선택에 제약이 있고 부분 장애가 전체에 영향을 미칩니다. 조직 규모, 팀 성숙도, 시스템 복잡도를 고려하여 적절한 아키텍처를 선택해야 합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q5. 컨테이너 기술의 장점과 Kubernetes의 주요 구성 요소를 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>컨테이너는 애플리케이션과 실행 환경을 하나의 패키지로 묶어 일관된 실행 환경을 제공하는 가상화 기술입니다. 주요 장점으로는 환경 일관성으로 개발, 테스트, 운영 환경 간 차이를 제거하고, 가벼운 가상화로 VM보다 적은 리소스를 사용하며 빠른 시작이 가능합니다. 이식성이 뛰어나 어떤 환경에서도 동일하게 실행되고, 확장성과 효율성이 좋으며, DevOps 문화와 잘 맞습니다. Kubernetes는 컨테이너 오케스트레이션 플랫폼으로 여러 구성 요소가 있습니다. 마스터 노드의 API Server는 모든 요청의 진입점이고, etcd는 클러스터 상태를 저장하는 분산 키-값 저장소입니다. Scheduler는 Pod를 적절한 노드에 배치하고, Controller Manager는 desired state를 유지합니다. 워커 노드의 kubelet은 Pod의 생명주기를 관리하고, kube-proxy는 네트워크 프록시 역할을 하며, 컨테이너 런타임이 실제 컨테이너를 실행합니다. Pod는 하나 이상의 컨테이너를 그룹화한 최소 배포 단위이고, Service는 Pod에 대한 네트워크 접근을 제공하며, Deployment는 Pod의 선언적 업데이트를 관리합니다. ConfigMap과 Secret은 설정과 민감 정보를 관리하고, Ingress는 외부 트래픽의 라우팅을 담당합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q6. 로드 밸런싱의 알고리즘 종류와 L4, L7 로드 밸런서의 차이점을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>로드 밸런싱은 여러 서버에 트래픽을 분산하여 가용성과 성능을 향상시키는 기술입니다. 주요 알고리즘으로는 Round Robin이 요청을 순차적으로 분배하는 가장 간단한 방식이고, Weighted Round Robin은 서버 성능에 따라 가중치를 부여합니다. Least Connections는 현재 연결 수가 가장 적은 서버로 라우팅하고, Weighted Least Connections는 가중치를 고려한 최소 연결 방식입니다. IP Hash는 클라이언트 IP를 해시하여 일관된 서버로 연결하고, Least Response Time은 응답 시간이 가장 빠른 서버를 선택합니다. L4 로드 밸런서는 전송 계층에서 동작하여 IP 주소와 포트 번호를 기반으로 트래픽을 분산합니다. 패킷을 수정하지 않고 전달하는 투명 프록시 방식으로 성능이 빠르지만, 애플리케이션 내용을 이해하지 못해 세밀한 제어가 어렵습니다. L7 로드 밸런서는 애플리케이션 계층에서 동작하여 HTTP 헤더, 쿠키, URL 패스 등을 분석해 트래픽을 분산합니다. 콘텐츠 기반 라우팅, SSL 종료, 압축, 캐싱 등의 고급 기능을 제공하지만 처리 오버헤드가 있어 상대적으로 성능이 떨어집니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q7. 캐싱 전략(Cache-Aside, Write-Through, Write-Behind)을 설명하고 각각의 장단점을 말해주세요.</b></summary>
  <div class="accordion-content">
<p>캐싱은 자주 사용되는 데이터를 빠른 저장소에 임시 저장하여 성능을 향상시키는 기법입니다. Cache-Aside(Lazy Loading) 패턴은 애플리케이션이 캐시를 직접 관리하는 방식으로, 데이터 요청 시 캐시를 먼저 확인하고 없으면 데이터베이스에서 조회한 후 캐시에 저장합니다. 장점은 필요한 데이터만 캐시에 저장하여 메모리를 효율적으로 사용하고, 캐시 장애가 애플리케이션에 치명적이지 않다는 것입니다. 단점은 캐시 미스 시 지연시간이 증가하고, 데이터 불일치가 발생할 수 있다는 점입니다. Write-Through 패턴은 쓰기 시 캐시와 데이터베이스에 동시에 저장하는 방식입니다. 장점은 데이터 일관성이 보장되고 읽기 성능이 좋다는 것이고, 단점은 쓰기 성능이 느리고 캐시에 사용되지 않는 데이터가 저장될 수 있다는 점입니다. Write-Behind(Write-Back) 패턴은 캐시에 먼저 쓰고 나중에 비동기적으로 데이터베이스에 반영하는 방식입니다. 장점은 쓰기 성능이 매우 빠르고 데이터베이스 부하가 적다는 것이고, 단점은 캐시 장애 시 데이터 손실 위험과 구현 복잡성이 증가한다는 점입니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q8. 데이터베이스 샤딩(Sharding)과 복제(Replication)의 개념과 구현 방법을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>샤딩은 데이터베이스를 수평으로 분할하여 여러 서버에 분산 저장하는 기법입니다. 각 샤드는 전체 데이터의 일부분을 담당하며, 쓰기 성능과 저장 용량을 확장할 수 있습니다. 구현 방법으로는 Range-based 샤딩이 특정 범위로 데이터를 분할하고, Hash-based 샤딩이 해시 함수로 균등 분산하며, Directory-based 샤딩이 조회 서비스를 통해 위치를 찾습니다. 장점은 선형적 확장성과 성능 향상이지만, 단점은 크로스 샤드 조인의 복잡성, 리샤딩의 어려움, 데이터 분산의 불균형 가능성입니다. 복제는 데이터베이스의 복사본을 여러 서버에 유지하는 기법으로 가용성과 읽기 성능을 향상시킵니다. Master-Slave 복제는 마스터에서 쓰기를 처리하고 슬레이브에서 읽기를 처리하며, Master-Master 복제는 모든 노드에서 쓰기가 가능하지만 충돌 해결이 복잡합니다. 동기 복제는 모든 복제본에 동시에 쓰기가 완료되면 커밋하여 강한 일관성을 보장하지만 성능이 떨어지고, 비동기 복제는 마스터에서 커밋 후 복제본에 전파하여 성능은 좋지만 데이터 손실 위험이 있습니다. 복제 지연(replication lag)과 페일오버 처리가 주요 고려사항입니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q9. 서비스 디스커버리와 서비스 메시의 개념과 필요성을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>서비스 디스커버리는 마이크로서비스 환경에서 서비스들이 서로를 찾고 통신할 수 있게 하는 메커니즘입니다. 동적으로 생성되고 확장되는 서비스들의 위치 정보를 중앙에서 관리하여, 하드코딩된 주소 없이도 서비스 간 통신을 가능하게 합니다. 클라이언트 사이드 디스커버리는 클라이언트가 직접 서비스 레지스트리를 조회하고, 서버 사이드 디스커버리는 로드 밸런서가 대신 조회합니다. Consul, etcd, Eureka 등이 대표적인 서비스 레지스트리입니다. 서비스 메시는 마이크로서비스 간의 네트워크 통신을 관리하는 인프라 계층으로, 각 서비스에 사이드카 프록시를 배치하여 모든 네트워크 트래픽을 가로챕니다. 서비스 디스커버리, 로드 밸런싱, 장애 복구, 보안, 모니터링 기능을 애플리케이션 코드와 분리하여 제공합니다. 데이터 플레인(사이드카 프록시)과 컨트롤 플레인(관리 서버)으로 구성되며, Istio, Linkerd, Consul Connect가 대표적입니다. 트래픽 관리, mTLS를 통한 보안, 관찰성(옵저버빌리티) 향상, 정책 기반 접근 제어가 주요 기능입니다. 복잡성 증가와 성능 오버헤드가 단점이지만, 대규모 마이크로서비스 환경에서는 필수적인 인프라입니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q10. 메시지 큐와 이벤트 스트리밍의 차이점과 각각의 사용 사례를 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>메시지 큐는 시스템 간의 비동기 통신을 지원하는 미들웨어로, 생산자가 메시지를 큐에 보내면 소비자가 나중에 처리하는 방식입니다. Point-to-Point 모델에서는 하나의 소비자가 메시지를 처리하고, Publish-Subscribe 모델에서는 여러 구독자가 메시지를 받을 수 있습니다. 메시지 전달 보장(at-least-once, at-most-once, exactly-once), 순서 보장, 내구성이 주요 특성입니다. RabbitMQ, Amazon SQS, Azure Service Bus가 대표적이며, 작업 큐, 이메일 발송, 주문 처리 등에 사용됩니다. 이벤트 스트리밍은 연속적인 이벤트 스트림을 실시간으로 처리하는 시스템으로, 높은 처리량과 낮은 지연시간을 제공합니다. 로그 기반 저장 방식으로 이벤트를 순서대로 저장하고, 여러 소비자가 독립적으로 스트림을 읽을 수 있습니다. Apache Kafka, Amazon Kinesis, Azure Event Hubs가 대표적이며, 실시간 분석, 로그 수집, 이벤트 소싱, CDC(Change Data Capture)에 사용됩니다. 메시지 큐는 안정적인 작업 처리에 적합하고, 이벤트 스트리밍은 대용량 실시간 데이터 처리에 적합합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q11. API 게이트웨이의 역할과 주요 기능, 장단점을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>API 게이트웨이는 클라이언트와 백엔드 서비스 사이의 단일 진입점 역할을 하는 서버로, 마이크로서비스 아키텍처에서 중요한 구성 요소입니다. 주요 기능으로는 요청 라우팅을 통해 클라이언트 요청을 적절한 백엔드 서비스로 전달하고, 인증과 권한 부여를 중앙에서 처리합니다. 속도 제한(Rate Limiting)으로 서비스를 보호하고, 로깅과 모니터링으로 전체 API 사용량을 추적합니다. 요청/응답 변환을 통해 클라이언트와 서비스 간의 인터페이스 차이를 해결하고, SSL 종료, 압축, 캐싱 등의 횡단 관심사를 처리합니다. 장점으로는 클라이언트 복잡성 감소로 여러 서비스와 직접 통신할 필요가 없고, 보안과 정책을 중앙에서 관리할 수 있으며, 백엔드 서비스의 변경이 클라이언트에 영향을 주지 않습니다. 단점으로는 단일 장애점이 될 수 있고, 성능 병목이 발생할 가능성이 있으며, 복잡성이 증가하고 지연시간이 추가됩니다. Kong, AWS API Gateway, Zuul, Traefik 등이 대표적인 솔루션이며, 고가용성 설계와 적절한 캐싱 전략이 중요합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q12. 분산 시스템에서의 일관성 모델(강한 일관성, 결과적 일관성)을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>분산 시스템에서 일관성은 모든 노드가 같은 데이터를 보는 정도를 나타냅니다. 강한 일관성(Strong Consistency)은 모든 읽기 작업이 가장 최근에 쓰여진 값을 반환하는 것을 보장합니다. 모든 노드가 동시에 같은 상태를 유지하며, 분산 합의 알고리즘이나 동기 복제를 통해 구현됩니다. 장점은 애플리케이션 로직이 단순해지고 데이터 정확성이 보장되는 것이고, 단점은 성능과 가용성이 저하될 수 있다는 점입니다. 은행 거래나 재고 관리 같은 정확성이 중요한 시스템에 사용됩니다. 결과적 일관성(Eventual Consistency)은 일정 시간이 지나면 모든 노드가 같은 상태가 되는 것을 보장하지만, 중간 시점에는 노드 간 데이터가 다를 수 있습니다. 비동기 복제를 통해 구현되며, 성능과 가용성이 우수하지만 일시적인 데이터 불일치가 발생할 수 있습니다. 소셜 미디어 피드나 추천 시스템 같이 가용성이 중요한 서비스에 적합합니다. 중간 단계로는 세션 일관성(세션 내에서만 일관성 보장), 인과 일관성(인과 관계가 있는 연산의 순서 보장), 단조 읽기 일관성(시간이 지날수록 더 새로운 데이터 읽기 보장) 등이 있습니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q13. 오토스케일링(Auto Scaling)의 유형과 구현 방법, 고려사항을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>오토스케일링은 시스템 부하에 따라 자동으로 리소스를 확장하거나 축소하는 기능입니다. 수직적 스케일링(Vertical Scaling)은 개별 인스턴스의 성능을 향상시키는 방식으로, CPU나 메모리를 증가시킵니다. 빠르지만 물리적 한계가 있고 단일 장애점 문제가 있습니다. 수평적 스케일링(Horizontal Scaling)은 인스턴스 수를 늘리거나 줄이는 방식으로, 이론적으로 무한 확장이 가능하고 가용성이 높지만 애플리케이션이 분산 환경을 지원해야 합니다. 구현 방법으로는 반응형(Reactive) 스케일링이 현재 메트릭을 기반으로 스케일링하고, 예측형(Predictive) 스케일링이 과거 패턴을 분석하여 미리 스케일링합니다. 예약형(Scheduled) 스케일링은 정해진 시간에 스케일링을 수행합니다. 주요 메트릭으로는 CPU 사용률, 메모리 사용률, 네트워크 I/O, 큐 길이, 사용자 정의 메트릭이 있습니다. 고려사항으로는 워밍업 시간을 고려한 스케일 아웃 정책, 비용 최적화를 위한 스케일 인 정책, 진동(oscillation) 방지를 위한 쿨다운 기간 설정이 있습니다. 상태 저장 애플리케이션의 경우 세션 관리나 데이터 일관성 문제를 해결해야 하고, 로드 밸런서와의 연동도 중요합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q14. DevOps와 CI/CD 파이프라인의 클라우드 구현 방법을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>DevOps는 개발(Development)과 운영(Operations)을 통합하여 소프트웨어 배포 속도와 품질을 향상시키는 문화와 방법론입니다. 클라우드 환경에서는 Infrastructure as Code(IaC)를 통해 인프라를 코드로 관리하고, 컨테이너와 오케스트레이션으로 일관된 배포 환경을 제공합니다. CI/CD 파이프라인은 지속적 통합과 지속적 배포를 자동화하는 워크플로우입니다. CI(Continuous Integration) 단계에서는 코드 커밋 시 자동으로 빌드, 테스트, 정적 분석을 수행하고, 아티팩트를 생성합니다. CD(Continuous Delivery/Deployment)는 검증된 코드를 스테이징 환경에서 테스트한 후 운영 환경에 배포합니다. 클라우드 구현에서는 AWS CodePipeline, Azure DevOps, Google Cloud Build, GitLab CI/CD 등의 관리형 서비스를 활용할 수 있습니다. 주요 단계로는 소스 코드 관리(Git), 빌드 자동화(Docker 이미지 생성), 테스트 자동화(단위/통합/E2E 테스트), 보안 스캔, 인프라 프로비저닝(Terraform, CloudFormation), 배포(Blue-Green, Canary, Rolling), 모니터링과 알림이 있습니다. GitOps 패턴을 활용하여 Git을 배포 상태의 단일 진실 공급원으로 사용하고, 브랜치 전략에 따른 환경별 배포 정책을 수립해야 합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q15. 서버리스 컴퓨팅의 특징과 장단점, 적용 사례를 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>서버리스 컴퓨팅은 개발자가 서버 관리 없이 코드 실행에만 집중할 수 있는 클라우드 컴퓨팅 모델입니다. FaaS(Function as a Service)는 이벤트에 반응하여 함수를 실행하고, BaaS(Backend as a Service)는 인증, 데이터베이스, 스토리지 등의 백엔드 서비스를 제공합니다. 주요 특징으로는 이벤트 기반 실행으로 HTTP 요청, 파일 업로드, 스케줄러 이벤트 등에 반응하고, 자동 확장으로 동시 실행 수에 따라 인스턴스가 자동 생성됩니다. 사용한 만큼만 과금되는 종량제 요금 체계와 함수 수준의 세밀한 배포가 가능합니다. 장점으로는 서버 관리 부담 제거, 자동 확장성, 비용 효율성, 빠른 개발 속도, 높은 가용성이 있습니다. 단점으로는 콜드 스타트로 인한 지연시간, 실행 시간 제한, 상태 관리의 어려움, 벤더 종속성, 디버깅과 테스트의 복잡성이 있습니다. 적용 사례로는 API 백엔드 구현, 데이터 처리 파이프라인, 이미지 리사이징, 웹훅 처리, 스케줄된 작업, IoT 데이터 처리, 실시간 스트림 처리가 있습니다. AWS Lambda, Azure Functions, Google Cloud Functions가 대표적인 서비스이며, 이벤트 기반 아키텍처와 잘 결합됩니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q16. 분산 시스템에서의 장애 처리와 복구 전략을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>분산 시스템에서는 노드 장애, 네트워크 파티션, 소프트웨어 오류 등 다양한 장애가 발생할 수 있어 적절한 장애 처리 전략이 필요합니다. 장애 탐지 방법으로는 헬스체크를 통해 주기적으로 서비스 상태를 확인하고, 하트비트로 노드 간 생존 신호를 교환하며, 타임아웃 설정으로 응답 없는 노드를 감지합니다. 서킷 브레이커 패턴은 장애가 발생한 서비스 호출을 차단하여 연쇄 장애를 방지하고, 일정 시간 후 재시도를 통해 복구를 확인합니다. 재시도 전략에서는 단순 재시도, 지수 백오프, 지터 추가로 부하를 분산시키고, 최대 재시도 횟수를 설정하여 무한 루프를 방지합니다. 벌크헤드 패턴으로 리소스를 격리하여 한 부분의 장애가 전체에 영향을 주지 않도록 하고, 타임아웃 설정으로 응답 없는 요청을 조기에 중단합니다. 복구 전략으로는 자동 복구를 통해 헬스체크 실패 시 인스턴스를 자동 교체하고, 장애 조치(Failover)로 마스터 노드 장애 시 슬레이브를 승격시킵니다. 백업과 복원을 통해 데이터 손실을 방지하고, 롤백 메커니즘으로 문제가 있는 배포를 이전 버전으로 되돌립니다. 분산 합의 알고리즘(Raft, Paxos)을 활용하여 네트워크 파티션 상황에서도 일관성을 유지합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q17. 클라우드 보안의 주요 위협과 보안 모델, 대응 방안을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>클라우드 보안은 공유 책임 모델을 기반으로 하며, 클라우드 제공자는 인프라 보안을, 사용자는 애플리케이션과 데이터 보안을 담당합니다. 주요 위협으로는 데이터 유출로 인한 민감 정보 노출, 계정 하이재킹을 통한 무단 접근, 내부자 위협에 의한 악의적 활동, 안전하지 않은 API를 통한 공격, 멀티테넌시 환경에서의 격리 실패가 있습니다. 보안 모델로는 IAM(Identity and Access Management)을 통한 중앙집중식 사용자 관리, 최소 권한 원칙 적용, 다중 인증(MFA) 강화가 있습니다. 네트워크 보안에서는 VPC(Virtual Private Cloud)로 격리된 네트워크 환경을 구성하고, 보안 그룹과 NACL로 트래픽을 제어하며, VPN이나 전용선으로 안전한 연결을 제공합니다. 데이터 보안에서는 전송 중 암호화(TLS), 저장 시 암호화(AES), 키 관리 서비스(KMS) 활용이 중요합니다. 대응 방안으로는 CASB(Cloud Access Security Broker)를 통한 클라우드 서비스 가시성 확보, CSPM(Cloud Security Posture Management)으로 보안 설정 오류 탐지, 컨테이너 보안을 위한 이미지 스캐닝과 런타임 보호가 있습니다. 규정 준수를 위해 GDPR, HIPAA, SOC 2 등의 표준을 준수하고, 정기적인 보안 감사와 침투 테스트를 수행해야 합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q18. 분산 시스템의 모니터링과 로깅, 옵저버빌리티를 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>분산 시스템에서는 여러 서비스와 인프라 구성 요소가 상호작용하므로 포괄적인 모니터링과 로깅이 필요합니다. 옵저버빌리티(Observability)는 시스템의 내부 상태를 외부 출력을 통해 추론할 수 있는 능력으로, 메트릭, 로그, 트레이스의 세 기둥으로 구성됩니다. 메트릭은 시계열 수치 데이터로 CPU, 메모리, 응답시간, 처리량 등을 측정하며, Prometheus, CloudWatch, DataDog 등을 사용합니다. 대시보드로 시각화하고 임계값 기반 알림을 설정하여 문제를 조기에 감지합니다. 로그는 시스템 이벤트의 상세한 기록으로, 구조화된 로그(JSON) 형태로 생성하고 중앙집중식으로 수집합니다. ELK Stack(Elasticsearch, Logstash, Kibana)이나 EFK Stack(Fluentd)을 활용하여 로그를 수집, 저장, 분석합니다. 분산 트레이싱은 요청이 여러 서비스를 거치는 과정을 추적하는 기술로, 각 서비스에서 스팬(Span)을 생성하고 트레이스 ID로 연결합니다. OpenTelemetry, Jaeger, Zipkin 등을 사용하여 구현하며, 성능 병목과 오류 전파 경로를 식별할 수 있습니다. 상관관계 분석으로 여러 데이터 소스를 연결하여 근본 원인을 파악하고, SLI/SLO/SLA를 정의하여 서비스 품질을 측정합니다. 애플리케이션 성능 모니터링(APM)으로 코드 레벨의 성능을 추적하고, 합성 모니터링으로 사용자 경험을 시뮬레이션합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q19. 멀티 클라우드와 하이브리드 클라우드 전략의 장단점을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>멀티 클라우드는 여러 클라우드 제공업체의 서비스를 동시에 사용하는 전략이고, 하이브리드 클라우드는 온프레미스 인프라와 클라우드를 결합하는 전략입니다. 멀티 클라우드의 장점으로는 벤더 종속성 회피로 협상력을 강화하고, 각 제공업체의 최적 서비스를 선택할 수 있으며, 지리적 분산으로 글로벌 서비스가 가능하고, 위험 분산으로 한 제공업체의 장애가 전체에 미치는 영향을 줄일 수 있습니다. 단점으로는 관리 복잡성 증가, 통합 어려움, 데이터 일관성과 보안 관리의 복잡성, 네트워크 지연과 데이터 전송 비용이 있습니다. 하이브리드 클라우드의 장점으로는 기존 투자 보호로 온프레미스 시스템을 계속 활용하고, 규정 준수를 위해 민감한 데이터를 온프레미스에 유지하며, 비용 최적화로 워크로드에 따라 적절한 환경을 선택할 수 있습니다. 또한 점진적 마이그레이션이 가능하고 재해 복구 시 백업 환경으로 활용할 수 있습니다. 단점으로는 네트워크 연결성에 대한 의존도가 높고, 보안 경계가 복잡해지며, 일관된 관리가 어렵고 데이터 동기화 문제가 발생할 수 있습니다. 성공적인 구현을 위해서는 워크로드 분류, 데이터 거버넌스, 네트워크 아키텍처, 통합 관리 도구, 보안 정책 통일이 필요합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q20. 클라우드 비용 최적화 전략과 FinOps의 개념을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>클라우드 비용 최적화는 성능과 기능을 유지하면서 클라우드 지출을 줄이는 활동입니다. 주요 전략으로는 리소스 최적화에서 사용되지 않는 인스턴스를 식별하여 정리하고, 적절한 인스턴스 크기 선택, 예약 인스턴스나 스팟 인스턴스 활용으로 비용을 절감합니다. 스토리지 최적화에서는 데이터 라이프사이클 정책을 수립하여 오래된 데이터를 저렴한 스토리지로 이동시키고, 중복 제거와 압축을 활용합니다. 네트워크 비용 최적화에서는 데이터 전송 패턴을 분석하여 불필요한 트래픽을 줄이고, CDN을 활용하여 대역폭 비용을 절감합니다. 오토스케일링으로 수요에 따라 리소스를 동적 조정하고, 스케줄링으로 비업무 시간에 개발/테스트 환경을 정지시킵니다. FinOps(Financial Operations)는 엔지니어링, 재무, 비즈니스 팀이 협력하여 클라우드 비용을 관리하는 문화적 실천 방법입니다. 알림(Inform) 단계에서 비용 가시성을 확보하고, 최적화(Optimize) 단계에서 우선순위에 따라 비용을 줄이며, 운영(Operate) 단계에서 거버넌스와 정책을 수립합니다. 주요 원칙으로는 팀 간 협업, 중앙집중식 비용 관리, 비즈니스 가치 기반 의사결정, 실시간 비용 추적, 지속적 최적화가 있습니다. 비용 할당 태그를 활용하여 부서별, 프로젝트별 비용을 추적하고, 예산 설정과 알림으로 비용 통제를 수행합니다.</p>
  </div>
</details>
  </div>
</details>

<!-- ② 심화 면접 Q&A -->
<details>
  <summary><span class="accordion-title">🚀 심화 면접 Q&amp;A</span> <span class="indicator">펼치기</span></summary>
  <div class="accordion-content">
<details>
  <summary style="font-size:1rem;"><b>Q21. 분산 합의 알고리즘(Raft, Paxos)의 동작 원리와 차이점을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>분산 합의 알고리즘은 네트워크 분할이나 노드 장애 상황에서도 분산 시스템의 노드들이 하나의 값에 합의할 수 있게 하는 알고리즘입니다. Raft 알고리즘은 이해하기 쉽도록 설계된 알고리즘으로, 리더 선출, 로그 복제, 안전성의 세 부분으로 구성됩니다. 노드는 리더, 팔로워, 후보자 상태 중 하나를 가지며, 리더가 모든 클라이언트 요청을 처리하고 다른 노드에 로그 엔트리를 복제합니다. 리더 장애 시 팔로워가 후보자로 전환되어 새로운 리더를 선출하며, 과반수 투표를 통해 결정됩니다. 로그 엔트리는 과반수 노드에 복제되어야 커밋되며, 이를 통해 일관성을 보장합니다. Paxos는 더 오래된 알고리즘으로 이론적으로 완전하지만 이해하고 구현하기 어렵습니다. Proposer, Acceptor, Learner 역할로 구성되며, 2단계 프로토콜(Prepare/Promise, Accept/Accepted)을 통해 합의에 도달합니다. Multi-Paxos는 리더를 선출하여 효율성을 향상시킨 변형입니다. Raft의 장점은 이해하기 쉽고 구현이 간단하며 강력한 리더십 모델을 가진다는 것이고, Paxos는 더 유연하고 이론적으로 견고하지만 복잡합니다. 실제로는 etcd, Consul에서 Raft를, Chubby, Spanner에서 Paxos 변형을 사용합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q22. 이벤트 소싱(Event Sourcing)과 CQRS 패턴을 설명하고 장단점을 말해주세요.</b></summary>
  <div class="accordion-content">
<p>이벤트 소싱은 애플리케이션 상태의 모든 변경을 일련의 이벤트로 저장하는 패턴입니다. 현재 상태를 직접 저장하는 대신 상태 변경을 일으킨 이벤트들을 순서대로 저장하고, 현재 상태는 이벤트들을 재생하여 구성합니다. 이벤트는 불변(Immutable)이며 과거의 모든 상태 변경 이력을 완벽하게 보존합니다. CQRS(Command Query Responsibility Segregation)는 읽기와 쓰기 작업을 분리하는 패턴으로, 커맨드 모델은 데이터 변경을, 쿼리 모델은 데이터 조회를 담당합니다. 두 패턴은 함께 사용되어 시너지를 발휘합니다. 이벤트 소싱의 장점으로는 완전한 감사 추적이 가능하고, 임의 시점으로의 시간 여행이 가능하며, 자연스러운 이벤트 기반 아키텍처 구현이 가능합니다. 또한 도메인 이벤트가 비즈니스 요구사항을 직접 반영하고, 다양한 뷰를 생성할 수 있습니다. 단점으로는 복잡성 증가, 이벤트 스키마 진화의 어려움, 스냅샷 관리 필요, 쿼리 성능 이슈, 결과적 일관성으로 인한 복잡성이 있습니다. CQRS의 장점은 읽기와 쓰기 모델을 독립적으로 최적화할 수 있고, 복잡한 도메인 로직과 쿼리 로직을 분리할 수 있으며, 확장성과 성능을 향상시킬 수 있다는 것입니다. 금융, 전자상거래, 협업 도구 등 복잡한 비즈니스 로직과 감사 요구사항이 있는 도메인에 적합합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q23. Saga 패턴을 활용한 분산 트랜잭션 관리 방법을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>Saga 패턴은 마이크로서비스 환경에서 여러 서비스에 걸친 긴 비즈니스 트랜잭션을 관리하는 패턴입니다. 전통적인 ACID 트랜잭션 대신 일련의 로컬 트랜잭션으로 분해하고, 실패 시 보상 액션을 통해 일관성을 유지합니다. 두 가지 구현 방식이 있습니다. Choreography 방식은 각 서비스가 로컬 트랜잭션 완료 후 이벤트를 발행하고, 다른 서비스가 이를 수신하여 다음 단계를 진행하는 분산 조정 방식입니다. 서비스 간 결합도가 낮고 단순하지만, 복잡한 플로우에서는 추적이 어렵고 순환 종속성이 발생할 수 있습니다. Orchestration 방식은 중앙 오케스트레이터가 전체 Saga 플로우를 관리하고 각 서비스에 명령을 보내는 방식입니다. 중앙집중식 제어로 플로우 추적이 쉽고 복잡한 비즈니스 로직을 구현하기 좋지만, 오케스트레이터가 단일 장애점이 될 수 있고 서비스 간 결합도가 증가합니다. 보상 액션은 각 단계마다 정의되어야 하며, 멱등성을 보장해야 합니다. Saga 패턴의 장점은 마이크로서비스의 자율성을 유지하면서 분산 트랜잭션을 처리할 수 있고, 서비스별 데이터베이스를 유지할 수 있다는 것입니다. 단점은 결과적 일관성으로 인한 복잡성, 보상 로직의 복잡성, 디버깅과 모니터링의 어려움입니다. 주문 처리, 결제 시스템, 예약 시스템 등에서 활용됩니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q24. 데이터 레이크와 데이터 웨어하우스, 레이크하우스 아키텍처의 차이점을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>데이터 웨어하우스는 구조화된 데이터를 저장하는 중앙집중식 저장소로, 사전 정의된 스키마(Schema-on-Write)를 사용하여 데이터 품질과 일관성을 보장합니다. OLAP(Online Analytical Processing)에 최적화되어 있으며, 복잡한 쿼리와 비즈니스 인텔리전스에 적합합니다. 높은 성능과 일관성을 제공하지만 유연성이 부족하고 비용이 높습니다. 데이터 레이크는 원시 형태의 정형, 반정형, 비정형 데이터를 모두 저장할 수 있는 확장 가능한 저장소입니다. Schema-on-Read 방식으로 데이터를 먼저 저장하고 사용할 때 스키마를 적용합니다. 높은 유연성과 확장성, 낮은 비용을 제공하지만 데이터 품질 관리가 어렵고 &quot;데이터 늪&quot;이 될 위험이 있습니다. 레이크하우스는 데이터 레이크의 유연성과 데이터 웨어하우스의 관리 기능을 결합한 새로운 아키텍처입니다. Delta Lake, Apache Iceberg, Apache Hudi 같은 기술을 사용하여 데이터 레이크에 ACID 트랜잭션, 스키마 진화, 타임 트래블, 데이터 버전 관리 기능을 추가합니다. 단일 플랫폼에서 배치와 스트리밍 처리를 모두 지원하고, 머신러닝과 분석 워크로드를 통합할 수 있습니다. 스토리지와 컴퓨팅을 분리하여 독립적으로 확장할 수 있고, 오픈 포맷(Parquet, ORC)을 사용하여 벤더 종속성을 피할 수 있습니다. 각 아키텍처는 데이터 성격, 분석 요구사항, 조직 성숙도에 따라 선택해야 합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q25. 엣지 컴퓨팅의 개념과 클라우드 컴퓨팅과의 관계, 활용 사례를 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>엣지 컴퓨팅은 데이터 소스에 가까운 곳에서 컴퓨팅 처리를 수행하는 분산 컴퓨팅 패러다임입니다. 중앙집중화된 클라우드와 달리 네트워크의 가장자리(Edge)에 컴퓨팅 자원을 배치하여 지연시간을 줄이고 대역폭을 절약합니다. 클라우드 컴퓨팅과는 상호 보완적 관계로, 엣지에서 실시간 처리가 필요한 작업을 수행하고 클라우드에서 대용량 분석과 장기 저장을 담당합니다. 계층적 아키텍처로 디바이스 엣지(센서, IoT 기기), 인프라 엣지(기지국, 지역 데이터센터), 클라우드로 구성됩니다. 주요 특징으로는 낮은 지연시간으로 실시간 응답이 가능하고, 대역폭 절약으로 네트워크 비용을 줄이며, 데이터 프라이버시 향상으로 민감한 데이터를 로컬에서 처리할 수 있습니다. 또한 오프라인 동작이 가능하여 네트워크 연결이 불안정한 환경에서도 작동합니다. 활용 사례로는 자율주행차에서 실시간 의사결정, 스마트 팩토리에서 예측 유지보수, AR/VR 애플리케이션에서 몰입형 경험 제공, 스마트 시티에서 교통 관리와 공공 안전, 의료 분야에서 원격 진료와 실시간 모니터링이 있습니다. 5G 네트워크와 결합하여 MEC(Multi-access Edge Computing)로 발전하고 있으며, 컨테이너와 서버리스 기술을 활용한 엣지 네이티브 애플리케이션 개발이 증가하고 있습니다. 하지만 관리 복잡성, 보안 위험, 리소스 제약 등의 도전과제도 있습니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q26. 실시간 스트림 처리 시스템의 아키텍처와 구현 방법을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>실시간 스트림 처리는 연속적으로 생성되는 데이터를 실시간으로 처리하는 시스템으로, 배치 처리와 달리 데이터가 도착하는 즉시 처리합니다. 핵심 구성 요소로는 데이터 소스(센서, 로그, 트랜잭션), 메시지 브로커(Apache Kafka, Amazon Kinesis), 스트림 처리 엔진(Apache Flink, Apache Storm, Kafka Streams), 데이터 싱크(데이터베이스, 파일 시스템, 대시보드)가 있습니다. 처리 방식에는 레코드 단위 처리와 마이크로 배치 처리가 있으며, 시간 의미론으로는 이벤트 시간(실제 발생 시간)과 처리 시간(시스템 처리 시간)을 구분해야 합니다. 윈도우 연산으로는 텀블링 윈도우(고정 크기, 겹치지 않음), 슬라이딩 윈도우(고정 크기, 겹침), 세션 윈도우(활동 기반 가변 크기)가 있습니다. 워터마크를 사용하여 늦게 도착하는 데이터를 처리하고, 체크포인팅으로 장애 복구를 지원합니다. 정확히 한 번(Exactly-once) 처리 보장을 위해 트랜잭션 상태 관리와 멱등성 보장이 중요합니다. Lambda 아키텍처는 배치와 스트림 처리를 병행하여 완전성과 실시간성을 모두 확보하고, Kappa 아키텍처는 스트림 처리만으로 모든 데이터를 처리합니다. 활용 사례로는 실시간 추천 시스템, 사기 탐지, IoT 데이터 모니터링, 실시간 분석 대시보드, 알림 시스템이 있습니다. 백프레셔(Backpressure) 처리와 확장성 설계가 주요 고려사항입니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q27. 멀티테넌트 클라우드 아키텍처의 설계 패턴과 데이터 격리 전략을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>멀티테넌트 아키텍처는 하나의 애플리케이션 인스턴스가 여러 고객(테넌트)을 동시에 서비스하는 구조로, SaaS 모델의 핵심입니다. 테넌트 격리 방식에 따라 세 가지 모델로 구분됩니다. 데이터베이스 분리 모델은 각 테넌트가 독립된 데이터베이스를 사용하여 완전한 격리와 높은 보안을 제공하지만, 관리 복잡성과 비용이 높습니다. 스키마 분리 모델은 같은 데이터베이스 내에서 스키마로 테넌트를 구분하여 관리 효율성과 격리의 균형을 맞춥니다. 행 수준 분리 모델은 테넌트 ID 컬럼으로 데이터를 구분하여 가장 효율적이지만 보안 위험과 데이터 유출 가능성이 있습니다. 애플리케이션 계층에서는 테넌트 컨텍스트 관리가 중요하며, 요청 시 테넌트를 식별하고 전체 요청 라이프사이클 동안 컨텍스트를 유지해야 합니다. 리소스 격리를 위해 테넌트별 CPU, 메모리, 스토리지 할당량을 설정하고, QoS(Quality of Service) 관리로 성능 격리를 보장합니다. 확장성 설계에서는 수평적 샤딩으로 테넌트를 여러 인스턴스에 분산하고, 오토스케일링으로 테넌트 증가에 대응합니다. 보안 고려사항으로는 테넌트 간 데이터 유출 방지, 접근 권한 관리, 감사 로깅, 규정 준수가 있습니다. 커스터마이제이션을 위해 설정 기반 또는 플러그인 아키텍처를 구현하고, 테넌트별 브랜딩과 기능 토글을 지원합니다. 모니터링과 운영에서는 테넌트별 메트릭 수집, 비용 할당, 백업과 복구 전략을 수립해야 합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q28. 클라우드 네이티브 보안과 컨테이너 보안의 모범 사례를 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>클라우드 네이티브 보안은 동적이고 분산된 환경의 특성을 고려한 보안 접근법입니다. 시프트 레프트 보안으로 개발 단계부터 보안을 내재화하고, DevSecOps 문화를 통해 보안을 자동화합니다. 컨테이너 보안은 이미지, 런타임, 오케스트레이션 계층에서 각각 다른 보안 조치가 필요합니다. 이미지 보안에서는 최소 기본 이미지(Minimal Base Image) 사용, 취약점 스캐닝, 신뢰할 수 있는 레지스트리 사용, 이미지 서명 검증이 중요합니다. 정기적인 이미지 업데이트와 패치 관리, 멀티스테이지 빌드로 공격 표면 최소화를 수행합니다. 런타임 보안에서는 최소 권한 원칙을 적용하여 root 권한 실행을 피하고, 읽기 전용 파일 시스템을 사용하며, 보안 컨텍스트를 적절히 설정합니다. 런타임 보안 모니터링으로 비정상적인 프로세스 실행, 네트워크 활동, 파일 시스템 변경을 탐지합니다. Kubernetes 보안에서는 RBAC(Role-Based Access Control)으로 API 접근을 제어하고, Pod Security Standards로 보안 정책을 강제하며, 네트워크 정책으로 트래픽을 제한합니다. 서비스 메시를 활용하여 mTLS로 서비스 간 통신을 암호화하고, 정책 기반 접근 제어를 구현합니다. 비밀 정보 관리에서는 Kubernetes Secrets나 외부 키 관리 시스템을 사용하여 패스워드와 API 키를 안전하게 저장하고, 환경 변수나 코드에 하드코딩하지 않습니다. 공급망 보안을 위해 소프트웨어 구성 요소 목록(SBOM) 관리, 빌드 프로세스 무결성 보장, 배포 시 서명 검증을 수행합니다. 제로 트러스트 원칙을 적용하여 모든 접근을 의심하고 지속적으로 검증하며, 마이크로 세그멘테이션으로 공격 확산을 방지합니다.</p>
  </div>
</details>
  </div>
</details>

<!-- ③ 추가 예상 질문 Q&A -->
<details>
  <summary><span class="accordion-title">💡 추가 예상 질문 Q&amp;A</span> <span class="indicator">펼치기</span></summary>
  <div class="accordion-content">
<details>
  <summary style="font-size:1rem;"><b>Q29. Kubernetes의 고급 기능(Custom Resources, Operators, Helm)을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>Kubernetes는 확장 가능한 아키텍처를 통해 다양한 고급 기능을 제공합니다. Custom Resources(CRs)는 사용자가 정의한 리소스 타입으로, 기본 제공되는 Pod, Service 외에 애플리케이션별 객체를 생성할 수 있게 합니다. Custom Resource Definitions(CRDs)를 통해 새로운 리소스의 스키마를 정의하고, kubectl로 일반 Kubernetes 객체처럼 관리할 수 있습니다. Operators는 애플리케이션별 운영 지식을 자동화하는 소프트웨어 확장으로, CRDs와 Controller를 조합하여 복잡한 상태 저장 애플리케이션의 생명주기를 관리합니다. Operator Pattern은 인간 운영자의 지식을 코드로 인코딩하여 설치, 업그레이드, 백업, 복구 등의 작업을 자동화합니다. Prometheus Operator, MongoDB Operator 등이 대표적 예시입니다. Helm은 Kubernetes의 패키지 매니저로, 복잡한 애플리케이션 배포를 템플릿화하고 버전 관리할 수 있게 합니다. Chart는 Kubernetes 리소스들의 집합을 패키징한 것이고, Values를 통해 환경별 설정을 분리할 수 있습니다. 릴리스 관리로 배포 히스토리를 추적하고 롤백이 가능하며, 의존성 관리로 복잡한 애플리케이션 스택을 쉽게 배포할 수 있습니다. 이러한 고급 기능들은 Kubernetes를 단순한 컨테이너 오케스트레이터에서 완전한 애플리케이션 플랫폼으로 확장시킵니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q30. GitOps와 Infrastructure as Code(IaC)의 구현 방법과 장점을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>GitOps는 Git을 배포 상태의 단일 진실 공급원(Single Source of Truth)으로 사용하는 운영 모델입니다. 모든 시스템 상태를 Git 리포지토리에 선언적으로 정의하고, 실제 시스템 상태를 Git의 원하는 상태와 지속적으로 동기화합니다. Pull 기반 배포로 클러스터 내의 에이전트가 Git 리포지토리를 주기적으로 확인하여 변경사항을 적용하며, Push 기반 CI/CD와 달리 클러스터 외부에서 접근 권한이 불필요합니다. Argo CD, Flux, Jenkins X가 대표적인 GitOps 도구입니다. Infrastructure as Code(IaC)는 인프라를 코드로 정의하고 관리하는 접근법으로, 선언적 언어를 사용하여 원하는 인프라 상태를 기술합니다. Terraform, AWS CloudFormation, Azure ARM Templates, Pulumi가 주요 도구입니다. 장점으로는 버전 관리를 통한 인프라 변경 추적, 코드 리뷰를 통한 품질 관리, 자동화된 배포로 인한 일관성 보장, 재현 가능한 환경 구축이 있습니다. GitOps와 IaC를 결합하면 애플리케이션과 인프라를 모두 Git 워크플로우로 관리할 수 있어, 감사 추적성, 롤백 용이성, 재해 복구 능력이 향상됩니다. 멀티 환경 관리에서는 환경별 브랜치나 디렉토리 구조를 사용하고, 보안을 위해 민감한 정보는 별도 시크릿 관리 시스템을 활용합니다. 팀 협업 시 코드 리뷰와 승인 프로세스를 통해 변경을 검증하고, 자동화된 테스트로 인프라 코드의 품질을 보장합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q31. 카오스 엔지니어링의 개념과 분산 시스템에서의 적용 방법을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>카오스 엔지니어링은 시스템이 난류 상황에서도 견딜 수 있는 능력에 대한 신뢰를 구축하기 위해 분산 시스템에서 실험을 수행하는 분야입니다. 프로덕션 환경에서 의도적으로 장애를 주입하여 시스템의 약점을 발견하고 복원력을 향상시키는 것이 목표입니다. 기본 원칙으로는 정상 상태 행동을 정의하고, 실험군과 대조군을 설정하여 가설을 세운 후, 현실적인 이벤트(서버 크래시, 네트워크 지연, 하드 드라이브 오작동)를 도입합니다. 실험은 프로덕션에서 수행하되 최소한의 영향으로 시작하여 점진적으로 확대하며, 지속적으로 자동화를 증가시킵니다. 실험 유형으로는 리소스 공격(CPU, 메모리, 디스크 고갈), 네트워크 공격(지연, 패킷 손실, 분할), 상태 공격(프로세스 종료, 서비스 중단), 애플리케이션 공격(예외 주입, 타임아웃)이 있습니다. Netflix의 Chaos Monkey가 대표적인 도구로 랜덤하게 인스턴스를 종료하고, Chaos Kong은 전체 가용성 영역을 종료하며, Simian Army는 다양한 장애 시나리오를 시뮬레이션합니다. 구현 방법으로는 작은 규모에서 시작하여 점진적으로 확대하고, 관찰 가능성을 확보하여 실험 결과를 정확히 측정합니다. 안전장치를 설정하여 과도한 피해를 방지하고, 정기적인 실험을 통해 지속적으로 시스템을 강화합니다. 조직 문화적으로는 실패를 학습 기회로 받아들이고, 예상치 못한 약점을 발견하여 사전에 해결할 수 있게 합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q32. 서비스 메시(Service Mesh) 아키텍처와 Istio의 주요 기능을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>서비스 메시는 마이크로서비스 간의 네트워크 통신을 관리하는 인프라 계층으로, 서비스 로직과 네트워크 관련 기능을 분리합니다. 사이드카 프록시 패턴을 사용하여 각 서비스에 프록시를 배치하고, 모든 네트워크 트래픽을 가로채어 관리합니다. 데이터 플레인은 실제 트래픽을 처리하는 사이드카 프록시들로 구성되고, 컨트롤 플레인은 프록시들을 설정하고 관리하는 중앙 제어 시스템입니다. Istio는 가장 널리 사용되는 서비스 메시 플랫폼으로, Envoy 프록시를 데이터 플레인으로 사용합니다. 주요 구성 요소로는 Pilot이 트래픽 관리 정책을 프록시에 배포하고, Citadel이 보안 정책과 인증서를 관리하며, Galley가 구성 검증과 배포를 담당합니다. 트래픽 관리에서는 가중치 기반 라우팅, A/B 테스트, 카나리 배포, 서킷 브레이커, 타임아웃, 재시도 정책을 제공합니다. Virtual Service로 라우팅 규칙을 정의하고, Destination Rule로 로드 밸런싱과 연결 풀 설정을 관리합니다. 보안 기능으로는 mTLS(mutual TLS)를 자동으로 적용하여 서비스 간 통신을 암호화하고, 정책 기반 접근 제어로 세밀한 권한 관리를 수행합니다. 관찰성(Observability)에서는 분산 트레이싱(Jaeger), 메트릭 수집(Prometheus), 로깅을 통합 제공하여 마이크로서비스 환경의 가시성을 확보합니다. 정책 및 원격 측정 수집을 통해 동적으로 보안과 성능 정책을 적용할 수 있습니다. 복잡성 증가와 성능 오버헤드가 단점이지만, 대규모 마이크로서비스 환경에서는 운영 복잡성을 크게 줄여줍니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q33. 클라우드 데이터베이스 서비스(RDS, NoSQL)의 특징과 선택 기준을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>클라우드 데이터베이스 서비스는 관리형 서비스로 제공되어 데이터베이스 운영의 복잡성을 줄여줍니다. 관계형 데이터베이스 서비스(RDS)는 MySQL, PostgreSQL, Oracle, SQL Server 등을 완전 관리형으로 제공하며, 자동 백업, 패치 관리, 모니터링, 다중 AZ 배포를 지원합니다. 읽기 전용 복제본으로 읽기 성능을 확장하고, 자동 장애 조치로 고가용성을 보장합니다. Aurora는 클라우드 네이티브 관계형 데이터베이스로 MySQL과 PostgreSQL 호환성을 제공하면서 최대 5배 성능 향상과 자동 확장을 제공합니다. NoSQL 서비스로는 DynamoDB(키-값/문서), MongoDB Atlas(문서), Amazon Neptune(그래프), Redis ElastiCache(인메모리)가 있습니다. DynamoDB는 서버리스 확장과 한 자릿수 밀리초 성능을 제공하며, 글로벌 테이블로 다중 리전 복제를 지원합니다. 선택 기준으로는 데이터 구조와 관계의 복잡성을 고려해야 합니다. 복잡한 관계와 ACID 트랜잭션이 필요하면 관계형 데이터베이스를, 확장성과 유연성이 중요하면 NoSQL을 선택합니다. 성능 요구사항에서는 높은 처리량과 낮은 지연시간이 필요하면 인메모리 데이터베이스를, 복잡한 쿼리가 많으면 SQL 데이터베이스를 고려합니다. 운영 복잡성을 줄이려면 완전 관리형 서비스를, 세밀한 제어가 필요하면 자체 관리형을 선택합니다. 비용 측면에서는 예측 가능한 워크로드에는 예약 인스턴스를, 가변적인 워크로드에는 온디맨드나 서버리스를 고려합니다. 멀티 클라우드 전략이나 온프레미스 호환성이 필요하면 오픈소스 솔루션을 선택하는 것이 유리합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q34. 클라우드 네이티브 애플리케이션의 설계 원칙과 12-Factor App을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>클라우드 네이티브 애플리케이션은 클라우드 환경의 장점을 최대한 활용하도록 설계된 애플리케이션입니다. 마이크로서비스 아키텍처, 컨테이너화, DevOps, 지속적 배포를 핵심으로 하며, 확장성, 복원력, 관리 용이성을 제공합니다. 12-Factor App은 SaaS 애플리케이션 구축을 위한 방법론으로 클라우드 네이티브 설계의 기초입니다. 코드베이스(Codebase)는 하나의 앱이 하나의 코드베이스를 가지며 버전 관리되어야 합니다. 의존성(Dependencies)은 명시적으로 선언하고 격리해야 하며, 시스템 전체 패키지에 의존하지 않아야 합니다. 설정(Config)은 환경 변수로 저장하여 코드와 분리하고, 백업 서비스(Backing Services)는 네트워크를 통해 접근하는 연결된 리소스로 취급합니다. 빌드, 릴리스, 실행(Build, release, run)은 엄격히 분리하여 각 단계가 독립적으로 관리되어야 합니다. 프로세스(Processes)는 무상태로 실행되며 아무것도 공유하지 않아야 하고, 포트 바인딩(Port binding)으로 서비스를 외부에 노출합니다. 동시성(Concurrency)은 프로세스 모델로 확장하며, 폐기 가능성(Disposability)은 빠른 시작과 우아한 종료를 보장합니다. 개발/프로덕션 동등성(Dev/prod parity)으로 환경 간 차이를 최소화하고, 로그(Logs)는 이벤트 스트림으로 취급하며, 관리 프로세스(Admin processes)는 일회성 프로세스로 실행합니다. 이러한 원칙들은 현대적인 클라우드 플랫폼에서 확장 가능하고 유지보수 가능한 애플리케이션을 구축하는 기초가 됩니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q35. 클라우드 마이그레이션 전략(6R)과 실행 방법을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>클라우드 마이그레이션은 온프레미스 시스템을 클라우드로 이전하는 과정으로, AWS의 6R 전략이 널리 사용됩니다. Rehosting(Lift and Shift)은 애플리케이션을 최소한의 변경으로 클라우드로 이전하는 방식으로, 가장 빠르지만 클라우드 이점을 충분히 활용하지 못합니다. Replatforming(Lift, Tinker and Shift)은 핵심 아키텍처는 유지하면서 클라우드 기능을 일부 활용하는 방식으로, 데이터베이스를 RDS로 변경하는 것이 예시입니다. Repurchasing(Drop and Shop)은 기존 라이선스를 포기하고 SaaS 솔루션으로 이전하는 방식으로, 이메일을 Office 365로 변경하는 것이 대표적입니다. Refactoring(Re-architecting)은 클라우드 네이티브 아키텍처로 완전히 재설계하는 방식으로, 마이크로서비스나 서버리스로 전환하는 것입니다. Retiring은 더 이상 필요하지 않은 애플리케이션을 제거하는 것이고, Retaining은 현재로서는 이전하지 않고 온프레미스에 유지하는 것입니다. 실행 방법으로는 먼저 애플리케이션 포트폴리오를 평가하여 의존성, 복잡성, 비즈니스 가치를 분석합니다. 비즈니스 케이스를 작성하여 비용 효과와 위험을 평가하고, 파일럿 프로젝트로 작은 규모에서 시작합니다. 마이그레이션 웨이브를 계획하여 단계적으로 진행하고, 자동화 도구를 활용하여 일관성을 보장합니다. 교육과 스킬 개발을 통해 팀 역량을 강화하고, 거버넌스와 보안 정책을 수립합니다. 마이그레이션 후에는 최적화를 통해 비용과 성능을 개선하고, 클라우드 네이티브 기능을 점진적으로 도입합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q36. AI/ML 플랫폼의 클라우드 구현과 MLOps의 개념을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>클라우드 AI/ML 플랫폼은 머신러닝 모델의 전체 생명주기를 지원하는 통합 환경을 제공합니다. 데이터 준비에서는 대용량 데이터 저장소(Data Lake), 데이터 처리 서비스(Apache Spark), 데이터 라벨링 도구를 제공하고, 모델 개발에서는 Jupyter Notebook, GPU 인스턴스, 분산 학습 환경을 지원합니다. AWS SageMaker, Google Cloud AI Platform, Azure Machine Learning이 대표적인 서비스입니다. 사전 훈련된 모델(Pre-trained Models)을 API로 제공하여 빠른 개발을 지원하고, AutoML로 비전문가도 머신러닝을 활용할 수 있게 합니다. MLOps(Machine Learning Operations)는 머신러닝 모델의 개발, 배포, 모니터링을 자동화하는 DevOps 확장 개념입니다. 데이터 버전 관리(DVC), 모델 버전 관리, 실험 추적(MLflow, Weights &amp; Biases), 자동화된 파이프라인 구축이 핵심입니다. CI/CD 파이프라인에 모델 훈련, 검증, 배포를 통합하고, A/B 테스트를 통해 모델 성능을 비교합니다. 모델 드리프트 감지로 데이터 분포 변화를 모니터링하고, 자동 재훈련으로 성능을 유지합니다. 특징 저장소(Feature Store)로 재사용 가능한 특징을 관리하고, 모델 레지스트리로 버전과 메타데이터를 중앙 관리합니다. 모델 서빙에서는 REST API, 배치 처리, 실시간 스트리밍을 지원하고, 카나리 배포나 블루-그린 배포로 안전한 모델 업데이트를 수행합니다. 모니터링에서는 모델 정확도, 응답 시간, 데이터 품질, 편향성을 추적하여 지속적인 개선을 수행합니다.</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q37. 분산 시스템의 성능 최적화 전략과 병목 지점 해결 방법을 설명해주세요.</b></summary>
  <div class="accordion-content">
<p>분산 시스템의 성능 최적화는 다층적 접근이 필요합니다. 먼저 성능 목표를 명확히 정의하여 처리량(Throughput), 응답시간(Latency), 가용성(Availability)에 대한 SLA를 설정합니다. 병목 지점 식별을 위해 APM(Application Performance Monitoring) 도구로 전체 시스템을 모니터링하고, 분산 트레이싱으로 요청 경로를 추적합니다. 네트워크 최적화에서는 지역별 배포로 지연시간을 줄이고, CDN으로 정적 콘텐츠 전송을 가속화하며, HTTP/2나 gRPC로 프로토콜을 최적화합니다. 연결 풀링과 Keep-Alive로 연결 오버헤드를 줄이고, 압축으로 데이터 전송량을 감소시킵니다. 캐싱 전략에서는 다단계 캐시를 구성하여 브라우저, CDN, 애플리케이션, 데이터베이스 레벨에서 캐싱을 적용합니다. 캐시 일관성 관리와 적절한 TTL 설정이 중요하며, 캐시 워밍업으로 콜드 스타트를 방지합니다. 데이터베이스 최적화에서는 읽기 복제본으로 읽기 부하를 분산하고, 샤딩으로 쓰기 성능을 확장하며, 인덱스 최적화로 쿼리 성능을 향상시킵니다. 연결 풀 관리와 쿼리 최적화도 중요한 요소입니다. 애플리케이션 레벨에서는 비동기 처리로 블로킹을 줄이고, 배치 처리로 효율성을 높이며, 메모리 관리와 가비지 컬렉션을 최적화합니다. 알고리즘과 데이터 구조 최적화도 성능에 큰 영향을 미칩니다. 시스템 아키텍처에서는 마이크로서비스 경계를 적절히 설정하여 네트워크 호출을 최소화하고, 이벤트 기반 아키텍처로 결합도를 낮추며, 서킷 브레이커로 장애 전파를 방지합니다. 오토스케일링으로 동적 확장을 구현하고, 로드 밸런싱으로 부하를 고르게 분산시킵니다. 지속적인 모니터링과 프로파일링을 통해 새로운 병목 지점을 조기에 발견하고, 성능 테스트를 정기적으로 수행하여 성능 저하를 방지합니다.</p>
<p>---</p>
  </div>
</details>
  </div>
</details>

<!-- ④ 개념 요약 노트 -->
<details>
  <summary><span class="accordion-title">📚 클라우드 &amp; 분산 시스템 개념 요약 노트</span> <span class="indicator">펼치기</span></summary>
  <div class="accordion-content">
<h3>☁️ 클라우드 컴퓨팅 기초</h3>

<h4>서비스 모델</h4>

SaaS (Software as a Service)
├── 완성된 소프트웨어 제공
├── 예시: Gmail, Office 365, Salesforce
└── 사용자: 최종 사용자

PaaS (Platform as a Service)  
├── 개발 플랫폼 제공
├── 예시: Heroku, App Engine, Beanstalk
└── 사용자: 개발자

IaaS (Infrastructure as a Service)
├── 가상화된 인프라 제공
├── 예시: EC2, Compute Engine, Virtual Machines
└── 사용자: 시스템 관리자


<h4>배포 모델</h4>
<ul>
<li>퍼블릭 클라우드: 제3자 제공, 비용 효율적</li>
<li>프라이빗 클라우드: 단독 사용, 높은 보안</li>
<li>하이브리드 클라우드: 퍼블릭 + 프라이빗 결합</li>
<li>멀티 클라우드: 여러 클라우드 제공자 사용</li>
</ul>

<h3>🌐 분산 시스템 핵심 개념</h3>

<h4>CAP 정리</h4>

    Consistency (일관성)
        /        \
       /          \
  CP 시스템    CA 시스템 (이론적)
     /              \
    /                \
Partition            Availability
Tolerance              (가용성)
    \                /
     \              /
     AP 시스템 ----/


<h4>일관성 모델</h4>
<ul>
<li>강한 일관성: 즉시 모든 노드 동일</li>
<li>결과적 일관성: 최종적으로 일관</li>
<li>세션 일관성: 세션 내에서만 일관</li>
<li>인과 일관성: 인과관계 순서 보장</li>
</ul>

<h3>🐳 컨테이너 & 오케스트레이션</h3>

<h4>Docker vs VM</h4>
<table>
<thead><tr><th>특성</th><th>Docker</th><th>VM</th></tr></thead>
<tbody>
<tr><td>격리 수준</td><td>프로세스</td><td>하드웨어</td></tr>
<tr><td>오버헤드</td><td>낮음</td><td>높음</td></tr>
<tr><td>시작 시간</td><td>초 단위</td><td>분 단위</td></tr>
<tr><td>이식성</td><td>높음</td><td>낮음</td></tr>
<tr><td>보안</td><td>약함</td><td>강함</td></tr>
</tbody>
</table>
<h4>Kubernetes 아키텍처</h4>

Master Node:
├── API Server: 모든 요청 진입점
├── etcd: 클러스터 상태 저장
├── Scheduler: Pod 배치 결정
└── Controller Manager: 상태 관리

Worker Node:
├── kubelet: Pod 생명주기 관리
├── kube-proxy: 네트워크 프록시
└── Container Runtime: 컨테이너 실행


<h3>⚖️ 로드 밸런싱 & 확장성</h3>

<h4>로드 밸런싱 알고리즘</h4>
<ul>
<li>Round Robin: 순차적 분배</li>
<li>Weighted Round Robin: 가중치 기반</li>
<li>Least Connections: 최소 연결 수</li>
<li>IP Hash: 클라이언트 IP 기반</li>
<li>Least Response Time: 응답시간 기반</li>
</ul>

<h4>확장성 패턴</h4>
<ul>
<li>수직 확장: CPU/메모리 증가</li>
<li>수평 확장: 인스턴스 수 증가</li>
<li>자동 확장: 메트릭 기반 동적 조정</li>
<li>예측 확장: 패턴 분석 기반</li>
</ul>

<h3>💾 캐싱 전략</h3>

<h4>캐싱 패턴</h4>

Cache-Aside (Lazy Loading):
Application → Cache → Database

Write-Through:
Application → Cache + Database (동시)

Write-Behind:
Application → Cache → Database (비동기)

Refresh-Ahead:
Cache → Database (만료 전 미리 갱신)


<h4>캐시 계층</h4>
<ul>
<li>Browser Cache: 클라이언트 캐시</li>
<li>CDN: 지리적 분산 캐시</li>
<li>Application Cache: 애플리케이션 메모리</li>
<li>Database Cache: 쿼리 결과 캐시</li>
</ul>

<h3>📡 메시징 & 이벤트</h3>

<h4>메시징 패턴</h4>
<ul>
<li>Point-to-Point: 1:1 메시지 전달</li>
<li>Publish-Subscribe: 1:N 메시지 브로드캐스트</li>
<li>Request-Reply: 동기식 요청-응답</li>
<li>Message Queue: 비동기 작업 큐</li>
</ul>

<h4>이벤트 아키텍처</h4>
<ul>
<li>Event Sourcing: 이벤트 기반 상태 관리</li>
<li>CQRS: 읽기/쓰기 모델 분리</li>
<li>Saga Pattern: 분산 트랜잭션 관리</li>
<li>Event-Driven: 이벤트 기반 통신</li>
</ul>

<h3>🔄 마이크로서비스 패턴</h3>

<h4>서비스 통신</h4>
<ul>
<li>동기 통신: REST API, GraphQL, gRPC</li>
<li>비동기 통신: 메시지 큐, 이벤트 스트림</li>
<li>서비스 디스커버리: Consul, Eureka, etcd</li>
<li>API 게이트웨이: 단일 진입점</li>
</ul>

<h4>데이터 관리</h4>
<ul>
<li>Database per Service: 서비스별 독립 DB</li>
<li>Shared Database: 공유 데이터베이스 (안티패턴)</li>
<li>Data Synchronization: 데이터 동기화</li>
<li>Event Sourcing: 이벤트 기반 데이터</li>
</ul>

<h3>🛡️ 분산 시스템 보안</h3>

<h4>보안 계층</h4>

Network Security:
├── VPC/VPN: 네트워크 격리
├── Firewall: 트래픽 제어
└── DDoS Protection: 공격 방어

Application Security:
├── Authentication: 인증 (OAuth, JWT)
├── Authorization: 권한 부여 (RBAC)
└── API Security: API 보호

Data Security:
├── Encryption in Transit: 전송 중 암호화
├── Encryption at Rest: 저장 시 암호화
└── Key Management: 키 관리 (KMS)


<h3>📊 모니터링 & 관찰성</h3>

<h4>관찰성 3요소</h4>
<ul>
<li><b>Metrics</b>: 시계열 수치 데이터</li>
<li>CPU, 메모리, 네트워크, 커스텀 메트릭</li>
<li><b>Logs</b>: 이벤트 기록</li>
<li>구조화된 로그 (JSON), 중앙집중식 수집</li>
<li><b>Traces</b>: 분산 추적</li>
<li>요청 경로 추적, 성능 병목 식별</li>
</ul>

<h4>모니터링 도구</h4>
<ul>
<li>Prometheus + Grafana: 메트릭 &amp; 대시보드</li>
<li>ELK Stack: 로그 수집 &amp; 분석</li>
<li>Jaeger/Zipkin: 분산 트레이싱</li>
<li>APM: 애플리케이션 성능 모니터링</li>
</ul>

<h3>🚀 DevOps & CI/CD</h3>

<h4>CI/CD 파이프라인</h4>

Source → Build → Test → Deploy → Monitor
  ↑                               ↓
  ←←←←← Feedback Loop ←←←←←←←←←←←←←


<h4>Infrastructure as Code</h4>
<ul>
<li>Terraform: 멀티 클라우드 프로비저닝</li>
<li>CloudFormation: AWS 네이티브</li>
<li>Ansible: 구성 관리</li>
<li>Helm: Kubernetes 패키지 관리</li>
</ul>

<h3>💰 클라우드 비용 최적화</h3>

<h4>비용 최적화 전략</h4>
<ul>
<li>인스턴스 최적화: 사이즈 조정, 예약 인스턴스</li>
<li>스토리지 최적화: 라이프사이클 정책, 압축</li>
<li>네트워크 최적화: CDN, 데이터 전송 최소화</li>
<li>오토스케일링: 수요 기반 자동 조정</li>
</ul>

<h4>FinOps 원칙</h4>
<ul>
<li>실시간 비용 가시성</li>
<li>팀 간 협업</li>
<li>비즈니스 가치 기반 의사결정</li>
<li>지속적 최적화</li>
</ul>

<h3>🎯 아키텍처 패턴</h3>

<h4>분산 시스템 패턴</h4>
<ul>
<li>Circuit Breaker: 장애 전파 방지</li>
<li>Bulkhead: 리소스 격리</li>
<li>Retry: 재시도 로직</li>
<li>Timeout: 타임아웃 설정</li>
<li>Rate Limiting: 요청 제한</li>
</ul>

<h4>확장성 패턴</h4>
<ul>
<li>Database Sharding: 수평 분할</li>
<li>Read Replicas: 읽기 복제본</li>
<li>CQRS: 읽기/쓰기 분리</li>
<li>Event Sourcing: 이벤트 기반 저장</li>
</ul>

<h3>🔮 신기술 동향</h3>

<h4>서버리스 컴퓨팅</h4>
<ul>
<li>FaaS: 함수 기반 실행</li>
<li>BaaS: 백엔드 서비스 제공</li>
<li>이벤트 기반 아키텍처</li>
<li>콜드 스타트 최적화</li>
</ul>

<h4>엣지 컴퓨팅</h4>
<ul>
<li>지연시간 최소화</li>
<li>대역폭 절약</li>
<li>로컬 데이터 처리</li>
<li>5G + MEC 결합</li>
</ul>

<h4>AI/ML 플랫폼</h4>
<ul>
<li>MLOps: ML 개발/운영 자동화</li>
<li>AutoML: 자동화된 모델 개발</li>
<li>모델 서빙: 실시간/배치 추론</li>
<li>특징 저장소: 재사용 가능한 특징 관리</li>
</ul>

<h3>💡 면접 대비 팁</h3>

<h4>기술적 질문 대응</h4>
1. <b>CAP 정리</b> 정확히 이해하고 실제 사례 설명
2. <b>트레이드오프 분석</b> 능력 보여주기
3. <b>확장성 시나리오</b> 구체적 설계 방안 제시
4. <b>장애 처리</b> 경험과 해결 방법 설명
5. <b>비용 최적화</b> 실무 경험 공유

<h4>시스템 설계 질문</h4>
<ul>
<li>요구사항 명확화</li>
<li>용량 추정 (QPS, 저장 용량)</li>
<li>고수준 아키텍처 설계</li>
<li>상세 컴포넌트 설계</li>
<li>확장성과 가용성 고려</li>
<li>모니터링과 운영 방안</li>
</ul>

<h4>실무 경험 어필</h4>
<ul>
<li>실제 프로젝트 사례</li>
<li>문제 해결 과정</li>
<li>성능 개선 결과</li>
<li>팀 협업 경험</li>
<li>지속적 학습 자세</li>
</ul>

<h3>📚 추천 학습 자료</h3>

<h4>자격증</h4>
<ul>
<li>AWS Solutions Architect</li>
<li>Google Cloud Professional</li>
<li>Azure Solutions Architect</li>
<li>Kubernetes (CKA, CKAD)</li>
<li>Docker Certified Associate</li>
</ul>

<h4>참고 도서</h4>
<ul>
<li>&quot;Designing Data-Intensive Applications&quot;</li>
<li>&quot;Building Microservices&quot;</li>
<li>&quot;Site Reliability Engineering&quot;</li>
<li>&quot;Cloud Native Patterns&quot;</li>
<li>&quot;Kubernetes in Action&quot;</li>
</ul>

<h4>온라인 리소스</h4>
<ul>
<li>클라우드 공식 문서</li>
<li>CNCF 프로젝트 문서</li>
<li>High Scalability 블로그</li>
<li>AWS Architecture Center</li>
<li>Google Cloud Architecture Framework</li>
</ul>
  </div>
</details>
