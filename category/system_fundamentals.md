---
layout: default
title: "시스템 기초 완전 정리"
---

<p class="breadcrumb"><a href="/cs_study/home.html">🏠 홈으로</a></p>

<section>
  <h2>시스템 기초 완전 정리 - 면접부터 개념까지</h2>
</section>

<details open>
  <summary><span class="accordion-title">면접 예상 질문 및 답변</span> <span class="indicator">펼치기</span></summary>
  <div class="accordion-content">
<details>
  <summary style="font-size:1rem;"><b>Q1: 프로세스와 스레드의 차이점을 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 프로세스는 실행 중인 프로그램의 인스턴스로 , 독립적인 메모리 공간을 가지며 다른 프로세스와 격리되어 있<br/>습니다 . 스레드는 프로세스 내에서 실행되는 작업 단위로 , 같은 프로세스의 다른 스레드와 메모리 공간을 공유합<br/>니다. 프로세스 간 통신은 IPC 를 사용해야 하지만 , 스레드 간 통신은 공유 메모리를 통해 쉽게 할 수 있습니다 . 프<br/>로세스 생성 비용이 더 크고 , 스레드가 더 가벼워 컨텍스트 스위칭 비용이 적습니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q2: 데드락 (Deadlock) 이란 무엇이고 어떻게 해결할 수 있나요 ?</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 데드락은 두 개 이상의 프로세스가 서로 상대방이 점유하고 있는 자원을 기다리며 무한 대기 상태에 빠지는 현<br/>상입니다 . 발생 조건은 상호배제 , 점유대기 , 비선점 , 순환대기입니다 . 해결 방법으로는 예방 (4 가지 조건 중 하나를<br/>차단), 회피 ( 은행가 알고리즘 ), 탐지 및 회복 ( 자원 할당 그래프 분석 ), 무시 ( 타조 알고리즘 ) 방법이 있습니다 . 실제<br/>로는 타임아웃 설정이나 자원 순서 지정 등이 많이 사용됩니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q3: 메모리 관리 기법에 대해 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 메모리 관리는 한정된 물리 메모리를 효율적으로 사용하기 위한 기법입니다 . 페이징은 가상 메모리를 고정 크<br/>기 페이지로 나누어 관리하며 , 내부 단편화가 발생할 수 있지만 관리가 간단합니다 . 세그멘테이션은 논리적 단위<br/>로 메모리를 나누어 관리하며 , 외부 단편화가 발생할 수 있지만 논리적 구조와 일치합니다 . 가상 메모리는 보조기<br/>억장치를 주기억장치처럼 사용하여 물리 메모리보다 큰 프로그램 실행을 가능하게 합니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q4: CPU 스케줄링 알고리즘들을 비교 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> FCFS는 먼저 온 순서대로 처리하는 가장 간단한 방식이지만 , 긴 작업이 먼저 오면 평균 대기시간이 길어집니<br/>다. SJF는 실행시간이 짧은 작업을 우선 처리하여 평균 대기시간을 최소화하지만 , 실행시간 예측이 어렵고 기아<br/>현상이 발생할 수 있습니다 . RR 은 시분할 방식으로 모든 프로세스에 공정한 CPU 시간을 제공하지만 , 컨텍스트<br/>스위칭 오버헤드가 있습니다 . Priority 스케줄링은 우선순위에 따라 처리하지만 낮은 우선순위 프로세스의 기아<br/>현상이 문제입니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q5: 동기화와 상호배제에 대해 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 동기화는 여러 프로세스나 스레드가 공유 자원에 접근할 때 일관성을 보장하기 위한 메커니즘입니다 . 상호배<br/>제는 한 번에 하나의 프로세스만 임계 영역에 접근할 수 있도록 하는 것입니다 . 구현 방법으로는 뮤텍스 ( 바이너리<br/>세마포어 ), 세마포어 ( 카운팅 ), 모니터 등이 있습니다 . 뮤텍스는 락을 얻은 프로세스만 해제할 수 있고 , 세마포어는<br/>자원의 개수를 관리하며 , 모니터는 고수준 동기화 구조체입니다 .<br/>컴퓨터 구조 관련</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q6: 캐시 메모리의 동작 원리와 종류를 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 캐시 메모리는 CPU 와 주기억장치 사이의 속도 차이를 줄이기 위한 고속 메모리입니다 . 지역성 원리 ( 시간적 지<br/>역성, 공간적 지역성 ) 를 이용해 자주 사용되는 데이터를 저장합니다 . L1, L2, L3 캐시로 계층화되어 있으며 , 레벨이<br/>낮을수록 용량은 작지만 속도가 빠릅니다 . 캐시 히트 시 빠른 접근이 가능하지만 , 캐시 미스 시 메모리에서 데이<br/>터를 가져와야 합니다 . 교체 정책으로는 LRU, FIFO, Random 등이 있습니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q7: CPU 의 파이프라인에 대해 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 파이프라인은 명령어 실행 과정을 여러 단계로 나누어 동시에 처리하여 처리량을 높이는 기술입니다 . 일반적<br/>으로 인출 (Fetch), 해독 (Decode), 실행 (Execute), 메모리 접근 (Memory), 쓰기 (Write-back) 단계로 구성됩니다 .<br/>파이프라인 해저드로는 구조적 해저드 ( 자원 충돌 ), 데이터 해저드 ( 종속성 ), 제어 해저드 ( 분기 ) 가 있으며 , 이를 해결<br/>하기 위해 포워딩 , 분기 예측 , 스톨 등의 기법을 사용합니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q8: 명령어 집합 구조 (ISA) 에 대해 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> ISA는 소프트웨어와 하드웨어 간의 인터페이스로 , CPU 가 인식할 수 있는 명령어들의 집합입니다 . CISC 는 복<br/>잡하고 다양한 명령어를 제공하여 프로그램 크기를 줄일 수 있지만 , 하드웨어가 복잡해집니다 . RISC 는 단순하고<br/>규격화된 명령어를 사용하여 하드웨어가 단순하고 파이프라인에 유리하지만 , 프로그램 크기가 커질 수 있습니다 .<br/>현재는 두 방식의 장점을 결합한 하이브리드 방식이 주로 사용됩니다 .<br/>네트워크 관련</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q9: OSI 7 계층 모델에 대해 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> OSI 7계층은 네트워크 통신을 7 개 계층으로 나누어 표준화한 모델입니다 . 물리계층 (1 층 ) 은 비트 전송 , 데이터<br/>링크계층 (2 층 ) 은 프레임 전송과 오류 검출 , 네트워크계층 (3 층 ) 은 패킷 라우팅 , 전송계층 (4 층 ) 은 종단 간 연결 , 세<br/>션계층 (5 층 ) 은 세션 관리 , 표현계층 (6 층 ) 은 데이터 변환 , 응용계층 (7 층 ) 은 사용자 인터페이스를 담당합니다 . 각 계<br/>층은 독립적이며 하위 계층의 서비스를 사용하여 상위 계층에 서비스를 제공합니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q10: TCP 와 UDP 의 차이점을 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> TCP는 연결 지향 프로토콜로 신뢰성 있는 데이터 전송을 보장합니다 . 3-way handshake 로 연결을 설정하고 ,<br/>순서 보장 , 오류 검출 및 재전송 , 흐름 제어 , 혼잡 제어 기능을 제공합니다 . UDP 는 비연결 지향 프로토콜로 빠른<br/>전송이 특징입니다 . 연결 설정 없이 데이터를 전송하며 , 신뢰성 보장은 없지만 오버헤드가 적어 실시간 통신에 적<br/>합합니다 . TCP는 웹 , 이메일 등에 , UDP 는 DNS, 스트리밍 등에 사용됩니다 .<br/>추가 면접 예상 질문 및 답변<br/>운영체제 심화</p>
  </div>
</details>
  </div>
</details>

<details>
  <summary><span class="accordion-title">추가 면접 예상 질문 및 답변</span> <span class="indicator">펼치기</span></summary>
  <div class="accordion-content">
<details>
  <summary style="font-size:1rem;"><b>Q11: 가상 메모리의 장단점과 페이지 교체 알고리즘을 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 가상 메모리의 장점은 물리 메모리 크기 제한 극복 , 메모리 효율성 향상 , 프로그램 간 메모리 보호입니다 . 단점<br/>은 주소 변환 오버헤드 , 페이지 폴트 시 성능 저하 , 스레싱 발생 가능성입니다 . 페이지 교체 알고리즘으로는<br/>FIFO(구현 간단하지만 성능 보장 안됨 ), LRU( 최적에 가깝지만 구현 복잡 ), LFU( 사용 빈도 기반 ), Clock(LRU 근사 ,<br/>참조 비트 사용 ) 등이 있습니다 . 각각 교체 성능과 구현 복잡도의 트레이드오프가 있습니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q12: 인터럽트와 시스템 콜의 차이점을 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 인터럽트는 하드웨어나 소프트웨어에서 CPU 에게 즉시 처리가 필요한 사건을 알리는 메커니즘입니다 . 하드웨<br/>어 인터럽트 (I/O, 타이머 ) 와 소프트웨어 인터럽트 ( 트랩 , 예외 ) 가 있습니다 . 시스템 콜은 사용자 프로그램이 운영체<br/>제 서비스를 요청하는 인터페이스입니다 . 인터럽트는 비동기적이고 예측 불가능하지만 , 시스템 콜은 프로그램에<br/>서 의도적으로 호출합니다 . 둘 다 모드 전환 ( 유저 모드 → 커널 모드 ) 을 수반합니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q13: 컨텍스트 스위칭이란 무엇이고 성능에 미치는 영향은 ?</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 컨텍스트 스위칭은 CPU 가 현재 실행 중인 프로세스나 스레드를 중단하고 다른 프로세스나 스레드로 실행을<br/>전환하는 과정입니다 . 현재 상태 ( 레지스터 , 프로그램 카운터 , 스택 포인터 등 ) 를 저장하고 새로운 프로세스의 상<br/>태를 복원합니다 . 성능 영향으로는 직접 비용 ( 상태 저장 / 복원 시간 ) 과 간접 비용 ( 캐시 무효화 , TLB 플러시 , 파이프<br/>라인 스톨 )이 있습니다 . 스레드 간 컨텍스트 스위칭이 프로세스 간보다 비용이 적습니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q14: 파일 시스템의 구조와 파일 할당 방법을 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 파일 시스템은 파일과 디렉터리를 저장하고 관리하는 시스템입니다 . 구조는 부트 블록 , 슈퍼 블록 ( 메타데이<br/>터), 아이노드 테이블 ( 파일 속성 ), 데이터 블록으로 구성됩니다 . 파일 할당 방법은 연속 할당 ( 빠른 접근 , 외부 단편<br/>화), 링크 할당 ( 동적 크기 , 순차 접근만 가능 ), 인덱스 할당 ( 직접 / 간접 접근 , 작은 파일에 오버헤드 ) 이 있습니다 . 현<br/>대 파일 시스템은 대부분 인덱스 할당의 변형을 사용합니다 .<br/>컴퓨터 구조 심화</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q15: 메모리 계층구조와 지역성 원리를 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 메모리 계층구조는 속도 , 용량 , 가격을 고려한 메모리 시스템입니다 . CPU 레지스터 → 캐시 (L1, L2, L3) → 주기<br/>억장치 → 보조기억장치 순으로 구성됩니다 . 상위로 갈수록 빠르고 비싸며 용량이 작습니다 . 지역성 원리는 시간<br/>적 지역성 ( 최근 접근한 데이터에 다시 접근 ) 과 공간적 지역성 ( 접근한 데이터 근처 데이터에 접근 ) 으로 나뉩니다 .<br/>이 원리를 활용해 캐시 시스템의 효율성을 높입니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q16: 분기 예측과 추측 실행에 대해 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 분기 예측은 조건부 분기 명령어의 결과를 미리 예측하여 파이프라인 성능을 향상시키는 기술입니다 . 정적 예<br/>측(컴파일러 힌트 ) 과 동적 예측 ( 실행 시 학습 ) 이 있습니다 . 동적 예측은 지역 예측 ( 개별 분기 ), 전역 예측 ( 분기 패<br/>턴), 하이브리드 예측을 사용합니다 . 추측 실행은 예측을 바탕으로 명령어를 미리 실행하되 , 예측이 틀리면 롤백합<br/>니다. 예측 정확도가 높을수록 성능 향상이 크지만 , 틀리면 페널티가 발생합니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q17: 슈퍼스칼라와 VLIW 아키텍처를 비교해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 슈퍼스칼라는 하드웨어가 동적으로 명령어 수준 병렬성을 찾아 여러 명령어를 동시 실행하는 구조입니다 . 아<br/>웃오브오더 실행 , 동적 스케줄링 , 레지스터 리네이밍 등을 사용하며 , 소프트웨어 호환성이 좋지만 하드웨어가 복<br/>잡합니다 . VLIW는 컴파일러가 정적으로 병렬성을 찾아 긴 명령어 워드에 여러 연산을 패킹하는 구조입니다 . 하드<br/>웨어가 단순하고 전력 효율적이지만 , 컴파일러 최적화에 의존하고 코드 호환성이 떨어집니다 .<br/>네트워크 심화</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q18: HTTP/HTTPS 의 차이점과 TLS/SSL 에 대해 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> HTTP는 평문으로 데이터를 전송하는 프로토콜로 보안에 취약합니다 . HTTPS 는 HTTP 에 TLS/SSL 보안 계층을<br/>추가한 것으로 , 암호화 , 무결성 , 인증을 제공합니다 . TLS/SSL 은 핸드셰이크 과정에서 서버 인증서 확인 , 암호화 알<br/>고리즘 협상 , 세션 키 교환을 수행합니다 . 대칭키 암호화로 데이터를 암호화하고 , 비대칭키 암호화로 세션키를 안<br/>전하게 교환합니다 . HTTPS 는 SEO 이점과 사용자 신뢰도 향상 등의 부가 효과도 있습니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q19: 라우팅 알고리즘과 프로토콜을 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 라우팅 알고리즘은 네트워크에서 최적 경로를 찾는 알고리즘입니다 . 거리 벡터 알고리즘 (RIP) 은 인접 라우터<br/>와 거리 정보를 교환하여 라우팅 테이블을 구축하지만 , 수렴 속도가 느리고 무한 계수 문제가 있습니다 . 링크 상<br/>태 알고리즘 (OSPF) 은 전체 네트워크 토폴로지를 파악하여 최단 경로를 계산하며 , 빠른 수렴과 정확성을 제공하<br/>지만 메모리와 계산 비용이 큽니다 . BGP 는 AS 간 라우팅을 담당하는 외부 게이트웨이 프로토콜입니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q20: DNS 의 동작 원리와 레코드 종류를 설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> DNS는 도메인 이름을 IP 주소로 변환하는 계층적 분산 데이터베이스 시스템입니다 . 클라이언트가 도메인을<br/>질의하면 , 로컬 DNS 서버가 루트 DNS → TLD DNS → 권한 DNS 순으로 재귀적 또는 반복적 질의를 수행합니다 .<br/>주요 레코드 종류는 A(IPv4 주소 ), AAAA(IPv6 주소 ), CNAME( 별명 ), MX( 메일 서버 ), NS( 네임서버 ), PTR( 역방향<br/>조회), TXT( 텍스트 정보 ) 등이 있습니다 . 캐싱을 통해 성능을 향상시키며 , TTL 로 캐시 유효 시간을 관리합니다 .<br/>시스템 기초 개념 정리<br/>1. 운영체제 (Operating System)<br/>1.1 운영체제 개요<br/>운영체제란 ?<br/>컴퓨터 하드웨어를 관리하고 응용 프로그램과 하드웨어 사이에서 중개 역할을 하는 시스템 소프트웨어입니다 .<br/>운영체제의 역할<br/>자원 관리: CPU, 메모리 , 입출력장치 , 파일 등의 자원을 효율적으로 관리<br/>프로세스 관리: 프로그램의 실행과 종료를 관리<br/>메모리 관리: 주기억장치의 할당과 회수를 관리<br/>파일 시스템 관리: 파일과 디렉터리를 관리<br/>입출력 관리: 입출력 장치와의 상호작용을 관리<br/>사용자 인터페이스 제공: 사용자와 시스템 간의 인터페이스 제공<br/>운영체제의 종류<br/>일괄 처리 시스템: 작업들을 모아서 순차적으로 처리<br/>시분할 시스템: 여러 사용자가 동시에 시스템을 사용<br/>실시간 시스템: 정해진 시간 내에 작업을 완료해야 하는 시스템<br/>분산 시스템: 여러 컴퓨터가 네트워크로 연결된 시스템<br/>다중 프로세서 시스템: 여러 CPU 를 가진 시스템<br/>1.2 프로세스 관리<br/>프로세스 (Process)<br/>실행 중인 프로그램의 인스턴스로 , 프로그램 코드와 관련된 모든 자원을 포함합니다 .<br/>프로세스 상태<br/>생성 (New): 프로세스가 생성되는 상태<br/>준비 (Ready): CPU 할당을 기다리는 상태<br/>실행 (Running): CPU를 할당받아 실행 중인 상태<br/>대기 (Waiting/Blocked): 입출력이나 이벤트를 기다리는 상태<br/>종료 (Terminated): 실행이 완료된 상태<br/>프로세스 제어 블록 (PCB)<br/>운영체제가 프로세스를 관리하기 위해 유지하는 자료구조입니다 .<br/>PCB 구성 요소<br/>프로세스 식별자 (PID)<br/>프로세스 상태<br/>프로그램 카운터<br/>레지스터 정보<br/>메모리 관리 정보<br/>계정 정보<br/>입출력 상태 정보<br/>스레드 (Thread)<br/>프로세스 내에서 실행되는 경량 프로세스로 , 같은 프로세스 내의 스레드들은 주소 공간을 공유합니다 .<br/>스레드의 장점<br/>빠른 생성과 종료<br/>적은 컨텍스트 스위칭 비용<br/>메모리 공유로 인한 통신 용이<br/>병렬 처리 가능<br/>스레드의 단점<br/>동기화 문제<br/>한 스레드의 오류가 전체 프로세스에 영향<br/>디버깅의 어려움<br/>1.3 CPU 스케줄링<br/>CPU 스케줄링이란 ?<br/>여러 프로세스가 CPU 를 사용하려 할 때 , 어떤 프로세스에게 CPU 를 할당할지 결정하는 것입니다 .<br/>스케줄링 목표<br/>CPU 사용률 최대화<br/>처리량 최대화<br/>대기 시간 최소화<br/>응답 시간 최소화<br/>반환 시간 최소화<br/>선점 vs 비선점 스케줄링<br/>비선점 (Non-preemptive): 실행 중인 프로세스가 자발적으로 CPU 를 반납할 때까지 대기<br/>선점 (Preemptive): 운영체제가 강제로 CPU 를 회수할 수 있음<br/>스케줄링 알고리즘<br/>FCFS (First Come First Served)<br/>먼저 온 순서대로 처리<br/>구현이 간단하지만 평균 대기시간이 길 수 있음<br/>비선점 방식<br/>SJF (Shortest Job First)<br/>실행시간이 가장 짧은 작업을 우선 처리<br/>평균 대기시간 최소화<br/>실행시간 예측의 어려움<br/>SRTF (Shortest Remaining Time First)<br/>SJF의 선점 버전<br/>남은 시간이 가장 짧은 프로세스를 우선 실행<br/>Priority Scheduling<br/>우선순위에 따라 CPU 할당<br/>기아 현상 발생 가능<br/>에이징 기법으로 해결<br/>Round Robin (RR)<br/>시분할 방식<br/>각 프로세스에 동일한 시간 할당 (time quantum)<br/>공정하지만 컨텍스트 스위칭 오버헤드<br/>Multi-level Queue<br/>여러 개의 큐를 사용<br/>각 큐마다 다른 스케줄링 알고리즘 적용<br/>프로세스 특성에 따라 큐 배정<br/>Multi-level Feedback Queue<br/>프로세스가 큐 간 이동 가능<br/>동적 우선순위 조정<br/>가장 일반적인 방식<br/>1.4 메모리 관리<br/>메모리 관리 목표<br/>메모리 보호: 프로세스 간 메모리 침범 방지<br/>메모리 공유: 필요에 따른 메모리 공유<br/>가상 주소: 논리 주소를 물리 주소로 변환<br/>메모리 할당: 효율적인 메모리 할당과 해제<br/>주소 바인딩<br/>논리 주소 ( 가상 주소 ) 를 물리 주소로 변환하는 과정입니다 .<br/>바인딩 시점<br/>컴파일 타임: 컴파일 시 절대 주소 결정<br/>로드 타임: 프로그램 로딩 시 주소 결정<br/>실행 타임: 실행 중 주소 변환<br/>연속 메모리 할당<br/>고정 분할<br/>메모리를 고정 크기 파티션으로 분할<br/>내부 단편화 발생<br/>가변 분할<br/>프로세스 크기에 따라 동적 분할<br/>외부 단편화 발생<br/>할당 알고리즘<br/>First Fit: 첫 번째 적절한 공간에 할당<br/>Best Fit: 가장 작은 적절한 공간에 할당<br/>Worst Fit: 가장 큰 공간에 할당<br/>페이징 (Paging)<br/>논리 메모리를 페이지 , 물리 메모리를 프레임으로 나누어 관리하는 방식입니다 .<br/>특징<br/>외부 단편화 해결<br/>내부 단편화 발생 가능 ( 마지막 페이지 )<br/>페이지 테이블을 통한 주소 변환<br/>페이지 테이블<br/>논리 페이지 번호를 물리 프레임 번호로 매핑<br/>각 프로세스마다 고유한 페이지 테이블 보유<br/>TLB (Translation Lookaside Buffer) 로 성능 향상<br/>세그멘테이션 (Segmentation)<br/>프로그램을 논리적 단위 ( 세그먼트 ) 로 나누어 관리하는 방식입니다 .<br/>특징<br/>논리적 구조와 일치<br/>외부 단편화 발생<br/>각 세그먼트마다 다른 크기 가능<br/>가상 메모리 (Virtual Memory)<br/>물리 메모리보다 큰 프로그램을 실행할 수 있도록 하는 기술입니다 .<br/>요구 페이징 (Demand Paging)<br/>필요한 페이지만 메모리에 로드<br/>페이지 폴트 발생 시 디스크에서 로드<br/>지역성 원리 활용<br/>페이지 교체 알고리즘<br/>FIFO: 가장 오래된 페이지 교체<br/>LRU: 가장 오랫동안 사용되지 않은 페이지 교체<br/>LFU: 가장 적게 사용된 페이지 교체<br/>Clock: 참조 비트를 이용한 LRU 근사<br/>스레싱 (Thrashing)<br/>페이지 폴트가 과도하게 발생하는 현상<br/>작업 집합 모델로 방지<br/>지역성 기반 할당으로 해결<br/>1.5 프로세스 동기화<br/>임계 영역 (Critical Section)<br/>여러 프로세스가 공유하는 자원에 접근하는 코드 영역입니다 .<br/>동기화 조건<br/>상호 배제 (Mutual Exclusion): 한 번에 하나의 프로세스만 임계 영역 진입<br/>진행 (Progress): 임계 영역이 비어있으면 진입 요청 프로세스 중 하나는 진입<br/>한정 대기 (Bounded Waiting): 무한 대기 방지<br/>동기화 도구<br/>뮤텍스 (Mutex)<br/>바이너리 세마포어<br/>락을 얻은 스레드만 해제 가능<br/>소유권 개념<br/>세마포어 (Semaphore)<br/>정수형 변수와 두 개의 원자 연산 (P, V)<br/>카운팅 세마포어 : 자원의 개수 관리<br/>바이너리 세마포어 : 상호 배제<br/>모니터 (Monitor)<br/>고수준 동기화 구조체<br/>상호 배제 자동 보장<br/>조건 변수를 통한 대기 / 신호<br/>스핀락 (Spinlock)<br/>바쁜 대기 방식<br/>짧은 임계 영역에 적합<br/>CPU 자원 낭비 가능<br/>데드락 (Deadlock)<br/>두 개 이상의 프로세스가 서로 상대방이 점유한 자원을 기다리며 무한 대기하는 상태입니다 .<br/>발생 조건<br/>1. 상호 배제: 자원을 동시에 사용할 수 없음<br/>2. 점유와 대기: 자원을 가진 채로 다른 자원을 대기<br/>3. 비선점: 강제로 자원을 빼앗을 수 없음<br/>4. 순환 대기: 자원 요청이 원형을 이룸<br/>해결 방법<br/>예방: 4가지 조건 중 하나를 차단<br/>회피: 은행가 알고리즘 등 안전한 상태 유지<br/>탐지와 회복: 데드락 발생 후 탐지하여 해결<br/>무시: 발생 확률이 낮다고 가정 ( 타조 알고리즘 )<br/>1.6 입출력 관리<br/>입출력 장치 분류<br/>블록 장치: 디스크 , 테이프 ( 블록 단위 접근 )<br/>문자 장치: 키보드 , 마우스 ( 문자 단위 접근 )<br/>입출력 제어 방식<br/>폴링 (Polling): CPU가 주기적으로 상태 확인<br/>인터럽트 (Interrupt): 장치가 완료 시 CPU 에 신호<br/>DMA (Direct Memory Access): 메모리 직접 접근<br/>디스크 스케줄링<br/>FCFS: 요청 순서대로 처리<br/>SSTF: 현재 위치에서 가장 가까운 요청 처리<br/>SCAN: 엘리베이터 알고리즘 , 한 방향으로 이동<br/>C-SCAN: 원형 SCAN, 한 방향으로만 서비스<br/>LOOK: 요청이 있는 곳까지만 이동<br/>2. 컴퓨터 구조 (Computer Architecture)<br/>2.1 컴퓨터 구조 개요<br/>폰 노이만 구조<br/>프로그램과 데이터를 동일한 메모리에 저장하는 구조입니다 .<br/>구성 요소<br/>CPU: 중앙 처리 장치<br/>메모리: 프로그램과 데이터 저장<br/>입출력 장치: 외부와의 인터페이스<br/>버스: 구성 요소 간 데이터 전송 경로<br/>하버드 구조<br/>명령어 메모리와 데이터 메모리를 분리한 구조입니다 .<br/>장점<br/>명령어와 데이터 동시 접근 가능<br/>보안성 향상<br/>성능 향상<br/>2.2 CPU 구조<br/>CPU 구성 요소<br/>산술논리연산장치 (ALU): 산술 및 논리 연산 수행<br/>제어장치: 명령어 해독 및 제어 신호 생성<br/>레지스터: 고속 저장 공간<br/>레지스터 종류<br/>프로그램 카운터 (PC): 다음 실행할 명령어 주소<br/>명령어 레지스터 (IR): 현재 실행 중인 명령어<br/>누적기 (ACC): 연산 결과 저장<br/>인덱스 레지스터: 주소 계산에 사용<br/>스택 포인터: 스택의 최상위 주소<br/>상태 레지스터: 플래그 비트 저장<br/>명령어 실행 사이클<br/>1. 인출 (Fetch): 메모리에서 명령어 읽기<br/>2. 해독 (Decode): 명령어 분석<br/>3. 실행 (Execute): 연산 수행<br/>4. 저장 (Store): 결과 저장<br/>2.3 메모리 계층구조<br/>메모리 계층<br/>레지스터: 가장 빠름 , 용량 작음<br/>캐시 메모리: 빠름 , 중간 용량<br/>주기억장치: 중간 속도 , 큰 용량<br/>보조기억장치: 느림 , 매우 큰 용량<br/>캐시 메모리<br/>CPU와 주기억장치 사이의 고속 버퍼 메모리입니다 .<br/>지역성 원리<br/>시간적 지역성: 최근 접근한 데이터에 다시 접근할 가능성이 높음<br/>공간적 지역성: 접근한 데이터 근처의 데이터에 접근할 가능성이 높음<br/>캐시 레벨<br/>L1 캐시: CPU 코어에 내장 , 가장 빠름<br/>L2 캐시: CPU 패키지 내부 , 중간 속도<br/>L3 캐시: 여러 코어가 공유 , 큰 용량<br/>캐시 매핑<br/>직접 매핑: 각 블록이 한 캐시 라인에만 매핑<br/>연관 매핑: 임의의 캐시 라인에 매핑 가능<br/>세트 연관 매핑: 여러 세트로 나누어 부분 연관<br/>교체 정책<br/>LRU: 가장 오래 사용하지 않은 블록 교체<br/>FIFO: 가장 먼저 들어온 블록 교체<br/>Random: 임의 블록 교체<br/>2.4 파이프라인<br/>파이프라인이란 ?<br/>명령어 처리 과정을 여러 단계로 나누어 동시에 처리하는 기법입니다 .<br/>5단계 파이프라인<br/>1. IF (Instruction Fetch): 명령어 인출<br/>2. ID (Instruction Decode): 명령어 해독<br/>3. EX (Execute): 실행<br/>4. MEM (Memory Access): 메모리 접근<br/>5. WB (Write Back): 결과 저장<br/>파이프라인 해저드<br/>구조적 해저드 (Structural Hazard)<br/>하드웨어 자원 충돌<br/>해결: 자원 추가 , 파이프라인 스톨<br/>데이터 해저드 (Data Hazard)<br/>명령어 간 데이터 의존성<br/>RAW, WAR, WAW 해저드<br/>해결: 포워딩 , 스톨 , 아웃오브오더 실행<br/>제어 해저드 (Control Hazard)<br/>분기 명령어로 인한 파이프라인 플러시<br/>해결: 분기 예측 , 지연 슬롯<br/>2.5 명령어 집합 구조 (ISA)<br/>CISC vs RISC<br/>CISC (Complex Instruction Set Computer)<br/>복잡하고 다양한 명령어<br/>가변 길이 명령어<br/>적은 레지스터<br/>마이크로프로그래밍<br/>예: x86<br/>RISC (Reduced Instruction Set Computer)<br/>단순하고 규격화된 명령어<br/>고정 길이 명령어<br/>많은 레지스터<br/>하드와이어드 제어<br/>예: ARM, MIPS<br/>주소 지정 방식<br/>즉시 주소법: 오퍼랜드가 명령어 내에 포함<br/>직접 주소법: 오퍼랜드가 메모리 주소<br/>간접 주소법: 메모리에 있는 주소를 참조<br/>레지스터 주소법: 레지스터 내의 값 사용<br/>인덱스 주소법: 베이스 주소 + 인덱스<br/>2.6 병렬 처리<br/>병렬성 분류<br/>명령어 수준 병렬성 (ILP): 명령어 간 병렬 실행<br/>스레드 수준 병렬성 (TLP): 스레드 간 병렬 실행<br/>프로세스 수준 병렬성: 프로세스 간 병렬 실행<br/>멀티프로세서 시스템<br/>공유 메모리 (UMA/NUMA)<br/>UMA: 모든 프로세서가 메모리에 균등하게 접근<br/>NUMA: 로컬 메모리에 빠르게 접근<br/>분산 메모리<br/>각 프로세서가 독립적인 메모리<br/>메시지 전달로 통신<br/>멀티코어 프로세서<br/>하나의 칩에 여러 CPU 코어<br/>캐시 공유 및 일관성 문제<br/>스레드 수준 병렬성 활용<br/>3. 네트워크 기초<br/>3.1 네트워크 개요<br/>네트워크란 ?<br/>컴퓨터나 다른 장치들을 연결하여 데이터를 공유할 수 있게 하는 시스템입니다 .<br/>네트워크 분류<br/>규모별<br/>PAN: 개인 영역 네트워크<br/>LAN: 근거리 통신망<br/>MAN: 도시권 통신망<br/>WAN: 광역 통신망<br/>전송 방식별<br/>유니캐스트: 1:1 통신<br/>브로드캐스트: 1:모든 수신자 통신<br/>멀티캐스트: 1:특정 그룹 통신<br/>토폴로지별<br/>버스형: 하나의 통신선에 모든 노드 연결<br/>스타형: 중앙 허브에 모든 노드 연결<br/>링형: 노드들이 원형으로 연결<br/>트리형: 계층적 구조<br/>메시형: 모든 노드가 서로 연결<br/>3.2 OSI 7 계층 모델<br/>1계층 : 물리 계층 (Physical Layer)<br/>기능: 비트 스트림을 전기적 / 광학적 신호로 변환<br/>장비: 허브 , 리피터 , 케이블<br/>프로토콜: RS-232, RJ-45<br/>2계층 : 데이터링크 계층 (Data Link Layer)<br/>기능: 프레임 단위 전송 , 오류 검출 / 정정 , 흐름 제어<br/>장비: 스위치 , 브릿지<br/>프로토콜: Ethernet, PPP, HDLC<br/>3계층 : 네트워크 계층 (Network Layer)<br/>기능: 패킷 라우팅 , 경로 결정<br/>장비: 라우터 , L3 스위치<br/>프로토콜: IP, ICMP, OSPF, BGP<br/>4계층 : 전송 계층 (Transport Layer)<br/>기능: 종단 간 통신 , 신뢰성 보장 , 포트 관리<br/>프로토콜: TCP, UDP<br/>5계층 : 세션 계층 (Session Layer)<br/>기능: 세션 설정 / 관리 / 종료<br/>프로토콜: NetBIOS, RPC<br/>6계층 : 표현 계층 (Presentation Layer)<br/>기능: 데이터 암호화 / 복호화 , 압축 , 형식 변환<br/>프로토콜: SSL/TLS, JPEG, MPEG<br/>7계층 : 응용 계층 (Application Layer)<br/>기능: 사용자 인터페이스 , 네트워크 서비스 제공<br/>프로토콜: HTTP, FTP, SMTP, DNS<br/>3.3 TCP/IP 모델<br/>TCP/IP 4 계층<br/>1. 네트워크 인터페이스 계층: OSI 1, 2 계층<br/>2. 인터넷 계층: OSI 3계층 (IP)<br/>3. 전송 계층: OSI 4계층 (TCP, UDP)<br/>4. 응용 계층: OSI 5, 6, 7 계층<br/>IP 주소<br/>네트워크에서 장치를 식별하는 고유한 주소입니다 .<br/>IPv4<br/>32비트 주소 (4 옥텟 )<br/>점분 십진법 표기 ( 예 : 192.168.1.1)<br/>주소 부족 문제<br/>IPv6<br/>128비트 주소<br/>16진법 표기 ( 예 : 2001:db8::1)<br/>주소 공간 확장<br/>주소 클래스 (IPv4)<br/>A클래스: 1.0.0.0 ~ 126.0.0.0 ( 대규모 네트워크 )<br/>B클래스: 128.0.0.0 ~ 191.255.0.0 ( 중규모 네트워크 )<br/>C클래스: 192.0.0.0 ~ 223.255.255.0 ( 소규모 네트워크 )<br/>서브넷팅<br/>네트워크를 작은 단위로 분할<br/>서브넷 마스크 사용<br/>CIDR 표기법 ( 예 : 192.168.1.0/24)<br/>3.4 주요 프로토콜<br/>TCP (Transmission Control Protocol)<br/>연결 지향적이고 신뢰성 있는 데이터 전송 프로토콜입니다 .<br/>특징<br/>연결 설정 (3-way handshake)<br/>순서 보장<br/>오류 검출 및 재전송<br/>흐름 제어<br/>혼잡 제어<br/>3-way Handshake<br/>1. 클라이언트 → 서버 : SYN<br/>2. 서버 → 클라이언트 : SYN+ACK<br/>3. 클라이언트 → 서버 : ACK<br/>4-way Handshake ( 연결 종료 )<br/>1. 클라이언트 → 서버 : FIN<br/>2. 서버 → 클라이언트 : ACK<br/>3. 서버 → 클라이언트 : FIN<br/>4. 클라이언트 → 서버 : ACK<br/>UDP (User Datagram Protocol)<br/>비연결 지향적이고 빠른 데이터 전송 프로토콜입니다 .<br/>특징<br/>연결 설정 없음<br/>순서 보장 없음<br/>신뢰성 보장 없음<br/>낮은 오버헤드<br/>실시간 통신에 적합<br/>HTTP (HyperText Transfer Protocol)<br/>웹에서 정보를 주고받기 위한 프로토콜입니다 .<br/>특징<br/>요청-응답 모델<br/>무상태 (Stateless)<br/>TCP 기반<br/>HTTP 메서드<br/>GET: 리소스 조회<br/>POST: 데이터 전송<br/>PUT: 리소스 수정<br/>DELETE: 리소스 삭제<br/>HEAD: 헤더 정보만 조회<br/>OPTIONS: 서버 옵션 조회<br/>HTTP 상태 코드<br/>1xx: 정보성 응답<br/>2xx: 성공 (200 OK)<br/>3xx: 리다이렉션 (301 Moved Permanently)<br/>4xx: 클라이언트 오류 (404 Not Found)<br/>5xx: 서버 오류 (500 Internal Server Error)<br/>HTTPS (HTTP Secure)<br/>HTTP에 SSL/TLS 보안 계층을 추가한 프로토콜입니다 .<br/>특징<br/>데이터 암호화<br/>서버 인증<br/>데이터 무결성 보장<br/>3.5 네트워크 장비<br/>허브 (Hub)<br/>1계층 장비<br/>모든 포트에 데이터 브로드캐스트<br/>반이중 통신<br/>충돌 도메인 공유<br/>스위치 (Switch)<br/>2계층 장비<br/>MAC 주소 학습<br/>전이중 통신<br/>충돌 도메인 분리<br/>라우터 (Router)<br/>3계층 장비<br/>IP 주소 기반 경로 결정<br/>브로드캐스트 도메인 분리<br/>서로 다른 네트워크 간 통신<br/>게이트웨이 (Gateway)<br/>서로 다른 프로토콜 간 변환<br/>네트워크 간 중개 역할<br/>3.6 라우팅<br/>라우팅이란 ?<br/>패킷이 목적지까지 가는 최적의 경로를 결정하는 과정입니다 .<br/>라우팅 테이블<br/>목적지 네트워크<br/>다음 홉 (Next Hop)<br/>메트릭 (비용 )<br/>인터페이스<br/>라우팅 프로토콜<br/>내부 게이트웨이 프로토콜 (IGP)<br/>RIP: 거리 벡터 , 홉 수 기준<br/>OSPF: 링크 상태 , 최단 경로 우선<br/>EIGRP: 하이브리드 , 대역폭과 지연 고려<br/>외부 게이트웨이 프로토콜 (EGP)<br/>BGP: 자율 시스템 간 라우팅 , 정책 기반<br/>3.7 DNS (Domain Name System)<br/>DNS란 ?<br/>도메인 이름을 IP 주소로 변환하는 분산 데이터베이스 시스템입니다 .<br/>DNS 구조<br/>루트 도메인: 최상위 (.)<br/>TLD (Top Level Domain): .com, .org, .net 등<br/>2차 도메인: google, naver 등<br/>서브 도메인: www, mail 등<br/>DNS 레코드 타입<br/>IPv4 주소<br/>AAAA: IPv6 주소<br/>CNAME: 별칭<br/>MX: 메일 서버<br/>NS: 네임 서버<br/>PTR: 역방향 조회<br/>TXT: 텍스트 정보<br/>DNS 조회 과정<br/>1. 로컬 DNS 서버에 질의<br/>2. 루트 DNS 서버 조회<br/>3. TLD DNS 서버 조회<br/>4. 권한 DNS 서버 조회<br/>5. IP 주소 반환<br/>4. 보안 기초<br/>4.1 정보보안 3 요소<br/>기밀성 (Confidentiality)<br/>인가된 사용자만 정보에 접근<br/>암호화 , 접근 제어<br/>무결성 (Integrity)<br/>정보의 정확성과 완전성 보장<br/>해시 함수 , 디지털 서명<br/>가용성 (Availability)<br/>필요할 때 정보에 접근 가능<br/>이중화 , 백업<br/>4.2 암호화<br/>대칭키 암호화<br/>암호화와 복호화에 같은 키 사용<br/>빠른 처리 속도<br/>키 관리의 어려움<br/>예: AES, DES<br/>비대칭키 암호화<br/>공개키와 개인키 쌍 사용<br/>키 교환 문제 해결<br/>느린 처리 속도<br/>예: RSA, ECC<br/>해시 함수<br/>임의 길이 데이터를 고정 길이로 변환<br/>일방향 함수<br/>무결성 검증에 사용<br/>예: SHA-256, MD5<br/>4.3 네트워크 보안<br/>방화벽 (Firewall)<br/>네트워크 접근 제어<br/>패킷 필터링<br/>상태 추적<br/>애플리케이션 게이트웨이<br/>IDS/IPS<br/>IDS: 침입 탐지 시스템<br/>IPS: 침입 방지 시스템<br/>시그니처 기반 / 행위 기반<br/>VPN (Virtual Private Network)<br/>공개 네트워크를 통한 안전한 통신<br/>터널링 , 암호화<br/>Site-to-Site, Remote Access<br/>5. 시스템 성능 평가<br/>5.1 성능 지표<br/>처리량 (Throughput)<br/>단위 시간당 처리된 작업 수<br/>TPS (Transaction Per Second)<br/>응답 시간 (Response Time)<br/>요청부터 응답까지 걸리는 시간<br/>대기 시간 + 처리 시간<br/>사용률 (Utilization)<br/>자원이 사용된 시간 비율<br/>CPU 사용률 , 메모리 사용률<br/>처리능력 (Capacity)<br/>시스템이 처리할 수 있는 최대 부하<br/>5.2 병목 현상<br/>병목 현상이란 ?<br/>시스템에서 가장 느린 구성 요소가 전체 성능을 제한하는 현상입니다 .<br/>병목점 식별<br/>성능 모니터링<br/>프로파일링<br/>부하 테스트<br/>해결 방법<br/>하드웨어 업그레이드<br/>알고리즘 최적화<br/>아키텍처 개선<br/>로드 밸런싱<br/>5.3 확장성<br/>수직 확장 (Scale Up)<br/>단일 시스템의 성능 향상<br/>CPU, 메모리 증설<br/>한계가 명확함<br/>수평 확장 (Scale Out)<br/>시스템 수 증가<br/>분산 처리<br/>무제한 확장 가능<br/>복잡성 증가</p>
  </div>
</details>
  </div>
</details>

<details>
  <summary><span class="accordion-title">시스템 기초 개념 정리 (전체)</span> <span class="indicator">펼치기</span></summary>
  <div class="accordion-content">
<p>시스템 기초 개념 정리</p><h2>1. 운영체제 (Operating System)</h2><h3>1.1 운영체제 개요</h3><p>운영체제란 ?</p><p>컴퓨터 하드웨어를 관리하고 응용 프로그램과 하드웨어 사이에서 중개 역할을 하는 시스템 소프트웨어입니다 .</p><p>운영체제의 역할</p><p>자원 관리: CPU, 메모리 , 입출력장치 , 파일 등의 자원을 효율적으로 관리</p><p>프로세스 관리: 프로그램의 실행과 종료를 관리</p><p>메모리 관리: 주기억장치의 할당과 회수를 관리</p><p>파일 시스템 관리: 파일과 디렉터리를 관리</p><p>입출력 관리: 입출력 장치와의 상호작용을 관리</p><p>사용자 인터페이스 제공: 사용자와 시스템 간의 인터페이스 제공</p><p>운영체제의 종류</p><p>일괄 처리 시스템: 작업들을 모아서 순차적으로 처리</p><p>시분할 시스템: 여러 사용자가 동시에 시스템을 사용</p><p>실시간 시스템: 정해진 시간 내에 작업을 완료해야 하는 시스템</p><p>분산 시스템: 여러 컴퓨터가 네트워크로 연결된 시스템</p><p>다중 프로세서 시스템: 여러 CPU 를 가진 시스템</p><h3>1.2 프로세스 관리</h3><p>프로세스 (Process)</p><p>실행 중인 프로그램의 인스턴스로 , 프로그램 코드와 관련된 모든 자원을 포함합니다 .</p><p>프로세스 상태</p><p>생성 (New): 프로세스가 생성되는 상태</p><p>준비 (Ready): CPU 할당을 기다리는 상태</p><p>실행 (Running): CPU를 할당받아 실행 중인 상태</p><p>대기 (Waiting/Blocked): 입출력이나 이벤트를 기다리는 상태</p><p>종료 (Terminated): 실행이 완료된 상태</p><p>프로세스 제어 블록 (PCB)</p><p>운영체제가 프로세스를 관리하기 위해 유지하는 자료구조입니다 .</p><p>PCB 구성 요소</p><p>프로세스 식별자 (PID)</p><p>프로세스 상태</p><p>프로그램 카운터</p><p>레지스터 정보</p><p>메모리 관리 정보</p><p>계정 정보</p><p>입출력 상태 정보</p><p>스레드 (Thread)</p><p>프로세스 내에서 실행되는 경량 프로세스로 , 같은 프로세스 내의 스레드들은 주소 공간을 공유합니다 .</p><p>스레드의 장점</p><p>빠른 생성과 종료</p><p>적은 컨텍스트 스위칭 비용</p><p>메모리 공유로 인한 통신 용이</p><p>병렬 처리 가능</p><p>스레드의 단점</p><p>동기화 문제</p><p>한 스레드의 오류가 전체 프로세스에 영향</p><p>디버깅의 어려움</p><h3>1.3 CPU 스케줄링</h3><p>CPU 스케줄링이란 ?</p><p>여러 프로세스가 CPU 를 사용하려 할 때 , 어떤 프로세스에게 CPU 를 할당할지 결정하는 것입니다 .</p><p>스케줄링 목표</p><p>CPU 사용률 최대화</p><p>처리량 최대화</p><p>대기 시간 최소화</p><p>응답 시간 최소화</p><p>반환 시간 최소화</p><p>선점 vs 비선점 스케줄링</p><p>비선점 (Non-preemptive): 실행 중인 프로세스가 자발적으로 CPU 를 반납할 때까지 대기</p><p>선점 (Preemptive): 운영체제가 강제로 CPU 를 회수할 수 있음</p><p>스케줄링 알고리즘</p><p>FCFS (First Come First Served)</p><p>먼저 온 순서대로 처리</p><p>구현이 간단하지만 평균 대기시간이 길 수 있음</p><p>비선점 방식</p><p>SJF (Shortest Job First)</p><p>실행시간이 가장 짧은 작업을 우선 처리</p><p>평균 대기시간 최소화</p><p>실행시간 예측의 어려움</p><p>SRTF (Shortest Remaining Time First)</p><p>SJF의 선점 버전</p><p>남은 시간이 가장 짧은 프로세스를 우선 실행</p><p>Priority Scheduling</p><p>우선순위에 따라 CPU 할당</p><p>기아 현상 발생 가능</p><p>에이징 기법으로 해결</p><p>Round Robin (RR)</p><p>시분할 방식</p><p>각 프로세스에 동일한 시간 할당 (time quantum)</p><p>공정하지만 컨텍스트 스위칭 오버헤드</p><p>Multi-level Queue</p><p>여러 개의 큐를 사용</p><p>각 큐마다 다른 스케줄링 알고리즘 적용</p><p>프로세스 특성에 따라 큐 배정</p><p>Multi-level Feedback Queue</p><p>프로세스가 큐 간 이동 가능</p><p>동적 우선순위 조정</p><p>가장 일반적인 방식</p><h3>1.4 메모리 관리</h3><p>메모리 관리 목표</p><p>메모리 보호: 프로세스 간 메모리 침범 방지</p><p>메모리 공유: 필요에 따른 메모리 공유</p><p>가상 주소: 논리 주소를 물리 주소로 변환</p><p>메모리 할당: 효율적인 메모리 할당과 해제</p><p>주소 바인딩</p><p>논리 주소 ( 가상 주소 ) 를 물리 주소로 변환하는 과정입니다 .</p><p>바인딩 시점</p><p>컴파일 타임: 컴파일 시 절대 주소 결정</p><p>로드 타임: 프로그램 로딩 시 주소 결정</p><p>실행 타임: 실행 중 주소 변환</p><p>연속 메모리 할당</p><p>고정 분할</p><p>메모리를 고정 크기 파티션으로 분할</p><p>내부 단편화 발생</p><p>가변 분할</p><p>프로세스 크기에 따라 동적 분할</p><p>외부 단편화 발생</p><p>할당 알고리즘</p><p>First Fit: 첫 번째 적절한 공간에 할당</p><p>Best Fit: 가장 작은 적절한 공간에 할당</p><p>Worst Fit: 가장 큰 공간에 할당</p><p>페이징 (Paging)</p><p>논리 메모리를 페이지 , 물리 메모리를 프레임으로 나누어 관리하는 방식입니다 .</p><p>특징</p><p>외부 단편화 해결</p><p>내부 단편화 발생 가능 ( 마지막 페이지 )</p><p>페이지 테이블을 통한 주소 변환</p><p>페이지 테이블</p><p>논리 페이지 번호를 물리 프레임 번호로 매핑</p><p>각 프로세스마다 고유한 페이지 테이블 보유</p><p>TLB (Translation Lookaside Buffer) 로 성능 향상</p><p>세그멘테이션 (Segmentation)</p><p>프로그램을 논리적 단위 ( 세그먼트 ) 로 나누어 관리하는 방식입니다 .</p><p>특징</p><p>논리적 구조와 일치</p><p>외부 단편화 발생</p><p>각 세그먼트마다 다른 크기 가능</p><p>가상 메모리 (Virtual Memory)</p><p>물리 메모리보다 큰 프로그램을 실행할 수 있도록 하는 기술입니다 .</p><p>요구 페이징 (Demand Paging)</p><p>필요한 페이지만 메모리에 로드</p><p>페이지 폴트 발생 시 디스크에서 로드</p><p>지역성 원리 활용</p><p>페이지 교체 알고리즘</p><p>FIFO: 가장 오래된 페이지 교체</p><p>LRU: 가장 오랫동안 사용되지 않은 페이지 교체</p><p>LFU: 가장 적게 사용된 페이지 교체</p><p>Clock: 참조 비트를 이용한 LRU 근사</p><p>스레싱 (Thrashing)</p><p>페이지 폴트가 과도하게 발생하는 현상</p><p>작업 집합 모델로 방지</p><p>지역성 기반 할당으로 해결</p><h3>1.5 프로세스 동기화</h3><p>임계 영역 (Critical Section)</p><p>여러 프로세스가 공유하는 자원에 접근하는 코드 영역입니다 .</p><p>동기화 조건</p><p>상호 배제 (Mutual Exclusion): 한 번에 하나의 프로세스만 임계 영역 진입</p><p>진행 (Progress): 임계 영역이 비어있으면 진입 요청 프로세스 중 하나는 진입</p><p>한정 대기 (Bounded Waiting): 무한 대기 방지</p><p>동기화 도구</p><p>뮤텍스 (Mutex)</p><p>바이너리 세마포어</p><p>락을 얻은 스레드만 해제 가능</p><p>소유권 개념</p><p>세마포어 (Semaphore)</p><p>정수형 변수와 두 개의 원자 연산 (P, V)</p><p>카운팅 세마포어 : 자원의 개수 관리</p><p>바이너리 세마포어 : 상호 배제</p><p>모니터 (Monitor)</p><p>고수준 동기화 구조체</p><p>상호 배제 자동 보장</p><p>조건 변수를 통한 대기 / 신호</p><p>스핀락 (Spinlock)</p><p>바쁜 대기 방식</p><p>짧은 임계 영역에 적합</p><p>CPU 자원 낭비 가능</p><p>데드락 (Deadlock)</p><p>두 개 이상의 프로세스가 서로 상대방이 점유한 자원을 기다리며 무한 대기하는 상태입니다 .</p><p>발생 조건</p><h2>1. 상호 배제: 자원을 동시에 사용할 수 없음</h2><h2>2. 점유와 대기: 자원을 가진 채로 다른 자원을 대기</h2><h2>3. 비선점: 강제로 자원을 빼앗을 수 없음</h2><h2>4. 순환 대기: 자원 요청이 원형을 이룸</h2><p>해결 방법</p><p>예방: 4가지 조건 중 하나를 차단</p><p>회피: 은행가 알고리즘 등 안전한 상태 유지</p><p>탐지와 회복: 데드락 발생 후 탐지하여 해결</p><p>무시: 발생 확률이 낮다고 가정 ( 타조 알고리즘 )</p><h3>1.6 입출력 관리</h3><p>입출력 장치 분류</p><p>블록 장치: 디스크 , 테이프 ( 블록 단위 접근 )</p><p>문자 장치: 키보드 , 마우스 ( 문자 단위 접근 )</p><p>입출력 제어 방식</p><p>폴링 (Polling): CPU가 주기적으로 상태 확인</p><p>인터럽트 (Interrupt): 장치가 완료 시 CPU 에 신호</p><p>DMA (Direct Memory Access): 메모리 직접 접근</p><p>디스크 스케줄링</p><p>FCFS: 요청 순서대로 처리</p><p>SSTF: 현재 위치에서 가장 가까운 요청 처리</p><p>SCAN: 엘리베이터 알고리즘 , 한 방향으로 이동</p><p>C-SCAN: 원형 SCAN, 한 방향으로만 서비스</p><p>LOOK: 요청이 있는 곳까지만 이동</p><h2>2. 컴퓨터 구조 (Computer Architecture)</h2><h3>2.1 컴퓨터 구조 개요</h3><p>폰 노이만 구조</p><p>프로그램과 데이터를 동일한 메모리에 저장하는 구조입니다 .</p><p>구성 요소</p><p>CPU: 중앙 처리 장치</p><p>메모리: 프로그램과 데이터 저장</p><p>입출력 장치: 외부와의 인터페이스</p><p>버스: 구성 요소 간 데이터 전송 경로</p><p>하버드 구조</p><p>명령어 메모리와 데이터 메모리를 분리한 구조입니다 .</p><p>장점</p><p>명령어와 데이터 동시 접근 가능</p><p>보안성 향상</p><p>성능 향상</p><h3>2.2 CPU 구조</h3><p>CPU 구성 요소</p><p>산술논리연산장치 (ALU): 산술 및 논리 연산 수행</p><p>제어장치: 명령어 해독 및 제어 신호 생성</p><p>레지스터: 고속 저장 공간</p><p>레지스터 종류</p><p>프로그램 카운터 (PC): 다음 실행할 명령어 주소</p><p>명령어 레지스터 (IR): 현재 실행 중인 명령어</p><p>누적기 (ACC): 연산 결과 저장</p><p>인덱스 레지스터: 주소 계산에 사용</p><p>스택 포인터: 스택의 최상위 주소</p><p>상태 레지스터: 플래그 비트 저장</p><p>명령어 실행 사이클</p><h2>1. 인출 (Fetch): 메모리에서 명령어 읽기</h2><h2>2. 해독 (Decode): 명령어 분석</h2><h2>3. 실행 (Execute): 연산 수행</h2><h2>4. 저장 (Store): 결과 저장</h2><h3>2.3 메모리 계층구조</h3><p>메모리 계층</p><p>레지스터: 가장 빠름 , 용량 작음</p><p>캐시 메모리: 빠름 , 중간 용량</p><p>주기억장치: 중간 속도 , 큰 용량</p><p>보조기억장치: 느림 , 매우 큰 용량</p><p>캐시 메모리</p><p>CPU와 주기억장치 사이의 고속 버퍼 메모리입니다 .</p><p>지역성 원리</p><p>시간적 지역성: 최근 접근한 데이터에 다시 접근할 가능성이 높음</p><p>공간적 지역성: 접근한 데이터 근처의 데이터에 접근할 가능성이 높음</p><p>캐시 레벨</p><p>L1 캐시: CPU 코어에 내장 , 가장 빠름</p><p>L2 캐시: CPU 패키지 내부 , 중간 속도</p><p>L3 캐시: 여러 코어가 공유 , 큰 용량</p><p>캐시 매핑</p><p>직접 매핑: 각 블록이 한 캐시 라인에만 매핑</p><p>연관 매핑: 임의의 캐시 라인에 매핑 가능</p><p>세트 연관 매핑: 여러 세트로 나누어 부분 연관</p><p>교체 정책</p><p>LRU: 가장 오래 사용하지 않은 블록 교체</p><p>FIFO: 가장 먼저 들어온 블록 교체</p><p>Random: 임의 블록 교체</p><h3>2.4 파이프라인</h3><p>파이프라인이란 ?</p><p>명령어 처리 과정을 여러 단계로 나누어 동시에 처리하는 기법입니다 .</p><p>5단계 파이프라인</p><h2>1. IF (Instruction Fetch): 명령어 인출</h2><h2>2. ID (Instruction Decode): 명령어 해독</h2><h2>3. EX (Execute): 실행</h2><h2>4. MEM (Memory Access): 메모리 접근</h2><h2>5. WB (Write Back): 결과 저장</h2><p>파이프라인 해저드</p><p>구조적 해저드 (Structural Hazard)</p><p>하드웨어 자원 충돌</p><p>해결: 자원 추가 , 파이프라인 스톨</p><p>데이터 해저드 (Data Hazard)</p><p>명령어 간 데이터 의존성</p><p>RAW, WAR, WAW 해저드</p><p>해결: 포워딩 , 스톨 , 아웃오브오더 실행</p><p>제어 해저드 (Control Hazard)</p><p>분기 명령어로 인한 파이프라인 플러시</p><p>해결: 분기 예측 , 지연 슬롯</p><h3>2.5 명령어 집합 구조 (ISA)</h3><p>CISC vs RISC</p><p>CISC (Complex Instruction Set Computer)</p><p>복잡하고 다양한 명령어</p><p>가변 길이 명령어</p><p>적은 레지스터</p><p>마이크로프로그래밍</p><p>예: x86</p><p>RISC (Reduced Instruction Set Computer)</p><p>단순하고 규격화된 명령어</p><p>고정 길이 명령어</p><p>많은 레지스터</p><p>하드와이어드 제어</p><p>예: ARM, MIPS</p><p>주소 지정 방식</p><p>즉시 주소법: 오퍼랜드가 명령어 내에 포함</p><p>직접 주소법: 오퍼랜드가 메모리 주소</p><p>간접 주소법: 메모리에 있는 주소를 참조</p><p>레지스터 주소법: 레지스터 내의 값 사용</p><p>인덱스 주소법: 베이스 주소 + 인덱스</p><h3>2.6 병렬 처리</h3><p>병렬성 분류</p><p>명령어 수준 병렬성 (ILP): 명령어 간 병렬 실행</p><p>스레드 수준 병렬성 (TLP): 스레드 간 병렬 실행</p><p>프로세스 수준 병렬성: 프로세스 간 병렬 실행</p><p>멀티프로세서 시스템</p><p>공유 메모리 (UMA/NUMA)</p><p>UMA: 모든 프로세서가 메모리에 균등하게 접근</p><p>NUMA: 로컬 메모리에 빠르게 접근</p><p>분산 메모리</p><p>각 프로세서가 독립적인 메모리</p><p>메시지 전달로 통신</p><p>멀티코어 프로세서</p><p>하나의 칩에 여러 CPU 코어</p><p>캐시 공유 및 일관성 문제</p><p>스레드 수준 병렬성 활용</p><h2>3. 네트워크 기초</h2><h3>3.1 네트워크 개요</h3><p>네트워크란 ?</p><p>컴퓨터나 다른 장치들을 연결하여 데이터를 공유할 수 있게 하는 시스템입니다 .</p><p>네트워크 분류</p><p>규모별</p><p>PAN: 개인 영역 네트워크</p><p>LAN: 근거리 통신망</p><p>MAN: 도시권 통신망</p><p>WAN: 광역 통신망</p><p>전송 방식별</p><p>유니캐스트: 1:1 통신</p><p>브로드캐스트: 1:모든 수신자 통신</p><p>멀티캐스트: 1:특정 그룹 통신</p><p>토폴로지별</p><p>버스형: 하나의 통신선에 모든 노드 연결</p><p>스타형: 중앙 허브에 모든 노드 연결</p><p>링형: 노드들이 원형으로 연결</p><p>트리형: 계층적 구조</p><p>메시형: 모든 노드가 서로 연결</p><h3>3.2 OSI 7 계층 모델</h3><p>1계층 : 물리 계층 (Physical Layer)</p><p>기능: 비트 스트림을 전기적 / 광학적 신호로 변환</p><p>장비: 허브 , 리피터 , 케이블</p><p>프로토콜: RS-232, RJ-45</p><p>2계층 : 데이터링크 계층 (Data Link Layer)</p><p>기능: 프레임 단위 전송 , 오류 검출 / 정정 , 흐름 제어</p><p>장비: 스위치 , 브릿지</p><p>프로토콜: Ethernet, PPP, HDLC</p><p>3계층 : 네트워크 계층 (Network Layer)</p><p>기능: 패킷 라우팅 , 경로 결정</p><p>장비: 라우터 , L3 스위치</p><p>프로토콜: IP, ICMP, OSPF, BGP</p><p>4계층 : 전송 계층 (Transport Layer)</p><p>기능: 종단 간 통신 , 신뢰성 보장 , 포트 관리</p><p>프로토콜: TCP, UDP</p><p>5계층 : 세션 계층 (Session Layer)</p><p>기능: 세션 설정 / 관리 / 종료</p><p>프로토콜: NetBIOS, RPC</p><p>6계층 : 표현 계층 (Presentation Layer)</p><p>기능: 데이터 암호화 / 복호화 , 압축 , 형식 변환</p><p>프로토콜: SSL/TLS, JPEG, MPEG</p><p>7계층 : 응용 계층 (Application Layer)</p><p>기능: 사용자 인터페이스 , 네트워크 서비스 제공</p><p>프로토콜: HTTP, FTP, SMTP, DNS</p><h3>3.3 TCP/IP 모델</h3><p>TCP/IP 4 계층</p><h2>1. 네트워크 인터페이스 계층: OSI 1, 2 계층</h2><h2>2. 인터넷 계층: OSI 3계층 (IP)</h2><h2>3. 전송 계층: OSI 4계층 (TCP, UDP)</h2><h2>4. 응용 계층: OSI 5, 6, 7 계층</h2><p>IP 주소</p><p>네트워크에서 장치를 식별하는 고유한 주소입니다 .</p><p>IPv4</p><p>32비트 주소 (4 옥텟 )</p><p>점분 십진법 표기 ( 예 : 192.168.1.1)</p><p>주소 부족 문제</p><p>IPv6</p><p>128비트 주소</p><p>16진법 표기 ( 예 : 2001:db8::1)</p><p>주소 공간 확장</p><p>주소 클래스 (IPv4)</p><p>A클래스: 1.0.0.0 ~ 126.0.0.0 ( 대규모 네트워크 )</p><p>B클래스: 128.0.0.0 ~ 191.255.0.0 ( 중규모 네트워크 )</p><p>C클래스: 192.0.0.0 ~ 223.255.255.0 ( 소규모 네트워크 )</p><p>서브넷팅</p><p>네트워크를 작은 단위로 분할</p><p>서브넷 마스크 사용</p><p>CIDR 표기법 ( 예 : 192.168.1.0/24)</p><h3>3.4 주요 프로토콜</h3><p>TCP (Transmission Control Protocol)</p><p>연결 지향적이고 신뢰성 있는 데이터 전송 프로토콜입니다 .</p><p>특징</p><p>연결 설정 (3-way handshake)</p><p>순서 보장</p><p>오류 검출 및 재전송</p><p>흐름 제어</p><p>혼잡 제어</p><p>3-way Handshake</p><h2>1. 클라이언트 → 서버 : SYN</h2><h2>2. 서버 → 클라이언트 : SYN+ACK</h2><h2>3. 클라이언트 → 서버 : ACK</h2><p>4-way Handshake ( 연결 종료 )</p><h2>1. 클라이언트 → 서버 : FIN</h2><h2>2. 서버 → 클라이언트 : ACK</h2><h2>3. 서버 → 클라이언트 : FIN</h2><h2>4. 클라이언트 → 서버 : ACK</h2><p>UDP (User Datagram Protocol)</p><p>비연결 지향적이고 빠른 데이터 전송 프로토콜입니다 .</p><p>특징</p><p>연결 설정 없음</p><p>순서 보장 없음</p><p>신뢰성 보장 없음</p><p>낮은 오버헤드</p><p>실시간 통신에 적합</p><p>HTTP (HyperText Transfer Protocol)</p><p>웹에서 정보를 주고받기 위한 프로토콜입니다 .</p><p>특징</p><p>요청-응답 모델</p><p>무상태 (Stateless)</p><p>TCP 기반</p><p>HTTP 메서드</p><p>GET: 리소스 조회</p><p>POST: 데이터 전송</p><p>PUT: 리소스 수정</p><p>DELETE: 리소스 삭제</p><p>HEAD: 헤더 정보만 조회</p><p>OPTIONS: 서버 옵션 조회</p><p>HTTP 상태 코드</p><p>1xx: 정보성 응답</p><p>2xx: 성공 (200 OK)</p><p>3xx: 리다이렉션 (301 Moved Permanently)</p><p>4xx: 클라이언트 오류 (404 Not Found)</p><p>5xx: 서버 오류 (500 Internal Server Error)</p><p>HTTPS (HTTP Secure)</p><p>HTTP에 SSL/TLS 보안 계층을 추가한 프로토콜입니다 .</p><p>특징</p><p>데이터 암호화</p><p>서버 인증</p><p>데이터 무결성 보장</p><h3>3.5 네트워크 장비</h3><p>허브 (Hub)</p><p>1계층 장비</p><p>모든 포트에 데이터 브로드캐스트</p><p>반이중 통신</p><p>충돌 도메인 공유</p><p>스위치 (Switch)</p><p>2계층 장비</p><p>MAC 주소 학습</p><p>전이중 통신</p><p>충돌 도메인 분리</p><p>라우터 (Router)</p><p>3계층 장비</p><p>IP 주소 기반 경로 결정</p><p>브로드캐스트 도메인 분리</p><p>서로 다른 네트워크 간 통신</p><p>게이트웨이 (Gateway)</p><p>서로 다른 프로토콜 간 변환</p><p>네트워크 간 중개 역할</p><h3>3.6 라우팅</h3><p>라우팅이란 ?</p><p>패킷이 목적지까지 가는 최적의 경로를 결정하는 과정입니다 .</p><p>라우팅 테이블</p><p>목적지 네트워크</p><p>다음 홉 (Next Hop)</p><p>메트릭 (비용 )</p><p>인터페이스</p><p>라우팅 프로토콜</p><p>내부 게이트웨이 프로토콜 (IGP)</p><p>RIP: 거리 벡터 , 홉 수 기준</p><p>OSPF: 링크 상태 , 최단 경로 우선</p><p>EIGRP: 하이브리드 , 대역폭과 지연 고려</p><p>외부 게이트웨이 프로토콜 (EGP)</p><p>BGP: 자율 시스템 간 라우팅 , 정책 기반</p><h3>3.7 DNS (Domain Name System)</h3><p>DNS란 ?</p><p>도메인 이름을 IP 주소로 변환하는 분산 데이터베이스 시스템입니다 .</p><p>DNS 구조</p><p>루트 도메인: 최상위 (.)</p><p>TLD (Top Level Domain): .com, .org, .net 등</p><p>2차 도메인: google, naver 등</p><p>서브 도메인: www, mail 등</p><p>DNS 레코드 타입</p><p>A: IPv4 주소</p><p>AAAA: IPv6 주소</p><p>CNAME: 별칭</p><p>MX: 메일 서버</p><p>NS: 네임 서버</p><p>PTR: 역방향 조회</p><p>TXT: 텍스트 정보</p><p>DNS 조회 과정</p><h2>1. 로컬 DNS 서버에 질의</h2><h2>2. 루트 DNS 서버 조회</h2><h2>3. TLD DNS 서버 조회</h2><h2>4. 권한 DNS 서버 조회</h2><h2>5. IP 주소 반환</h2><h2>4. 보안 기초</h2><h3>4.1 정보보안 3 요소</h3><p>기밀성 (Confidentiality)</p><p>인가된 사용자만 정보에 접근</p><p>암호화 , 접근 제어</p><p>무결성 (Integrity)</p><p>정보의 정확성과 완전성 보장</p><p>해시 함수 , 디지털 서명</p><p>가용성 (Availability)</p><p>필요할 때 정보에 접근 가능</p><p>이중화 , 백업</p><h3>4.2 암호화</h3><p>대칭키 암호화</p><p>암호화와 복호화에 같은 키 사용</p><p>빠른 처리 속도</p><p>키 관리의 어려움</p><p>예: AES, DES</p><p>비대칭키 암호화</p><p>공개키와 개인키 쌍 사용</p><p>키 교환 문제 해결</p><p>느린 처리 속도</p><p>예: RSA, ECC</p><p>해시 함수</p><p>임의 길이 데이터를 고정 길이로 변환</p><p>일방향 함수</p><p>무결성 검증에 사용</p><p>예: SHA-256, MD5</p><h3>4.3 네트워크 보안</h3><p>방화벽 (Firewall)</p><p>네트워크 접근 제어</p><p>패킷 필터링</p><p>상태 추적</p><p>애플리케이션 게이트웨이</p><p>IDS/IPS</p><p>IDS: 침입 탐지 시스템</p><p>IPS: 침입 방지 시스템</p><p>시그니처 기반 / 행위 기반</p><p>VPN (Virtual Private Network)</p><p>공개 네트워크를 통한 안전한 통신</p><p>터널링 , 암호화</p><p>Site-to-Site, Remote Access</p><h2>5. 시스템 성능 평가</h2><h3>5.1 성능 지표</h3><p>처리량 (Throughput)</p><p>단위 시간당 처리된 작업 수</p><p>TPS (Transaction Per Second)</p><p>응답 시간 (Response Time)</p><p>요청부터 응답까지 걸리는 시간</p><p>대기 시간 + 처리 시간</p><p>사용률 (Utilization)</p><p>자원이 사용된 시간 비율</p><p>CPU 사용률 , 메모리 사용률</p><p>처리능력 (Capacity)</p><p>시스템이 처리할 수 있는 최대 부하</p><h3>5.2 병목 현상</h3><p>병목 현상이란 ?</p><p>시스템에서 가장 느린 구성 요소가 전체 성능을 제한하는 현상입니다 .</p><p>병목점 식별</p><p>성능 모니터링</p><p>프로파일링</p><p>부하 테스트</p><p>해결 방법</p><p>하드웨어 업그레이드</p><p>알고리즘 최적화</p><p>아키텍처 개선</p><p>로드 밸런싱</p><h3>5.3 확장성</h3><p>수직 확장 (Scale Up)</p><p>단일 시스템의 성능 향상</p><p>CPU, 메모리 증설</p><p>한계가 명확함</p><p>수평 확장 (Scale Out)</p><p>시스템 수 증가</p><p>분산 처리</p><p>무제한 확장 가능</p><p>복잡성 증가</p>
  </div>
</details>
