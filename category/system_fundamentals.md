---
layout: default
title: "시스템 기초 완전 정리"
---

<p class="breadcrumb"><a href="/cs_study/home.html">🏠 홈으로</a></p>

<section>
  <h2>시스템 기초 완전 정리 - 면접부터 개념까지</h2>
</section>

<details open>
  <summary><span class="accordion-title">면접 예상 질문 및 답변</span> <span class="indicator">펼치기</span></summary>
  <div class="accordion-content">
<details>
  <summary style="font-size:1rem;"><b>Q1: 프로세스와  스레드의  차이점을  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 프로세스는  실행  중인  프로그램의  인스턴스로 , 독립적인  메모리  공간을  가지며  다른  프로세스와  격리되어  있<br/>습니다 . 스레드는  프로세스  내에서  실행되는  작업  단위로 , 같은  프로세스의  다른  스레드와  메모리  공간을  공유합<br/>니다. 프로세스  간  통신은  IPC 를  사용해야  하지만 , 스레드  간  통신은  공유  메모리를  통해  쉽게  할  수  있습니다 . 프<br/>로세스  생성  비용이  더  크고 , 스레드가  더  가벼워  컨텍스트  스위칭  비용이  적습니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q2: 데드락 (Deadlock) 이란  무엇이고  어떻게  해결할  수  있나요 ?</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 데드락은  두  개  이상의  프로세스가  서로  상대방이  점유하고  있는  자원을  기다리며  무한  대기  상태에  빠지는  현<br/>상입니다 . 발생  조건은  상호배제 , 점유대기 , 비선점 , 순환대기입니다 . 해결  방법으로는  예방 (4 가지  조건  중  하나를<br/>차단), 회피 ( 은행가  알고리즘 ), 탐지  및  회복 ( 자원  할당  그래프  분석 ), 무시 ( 타조  알고리즘 ) 방법이  있습니다 . 실제<br/>로는 타임아웃  설정이나  자원  순서  지정  등이  많이  사용됩니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q3: 메모리  관리  기법에  대해  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 메모리  관리는  한정된  물리  메모리를  효율적으로  사용하기  위한  기법입니다 . 페이징은  가상  메모리를  고정  크<br/>기 페이지로  나누어  관리하며 , 내부  단편화가  발생할  수  있지만  관리가  간단합니다 . 세그멘테이션은  논리적  단위<br/>로 메모리를  나누어  관리하며 , 외부  단편화가  발생할  수  있지만  논리적  구조와  일치합니다 . 가상  메모리는  보조기<br/>억장치를  주기억장치처럼  사용하여  물리  메모리보다  큰  프로그램  실행을  가능하게  합니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q4: CPU 스케줄링  알고리즘들을  비교  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> FCFS는  먼저  온  순서대로  처리하는  가장  간단한  방식이지만 , 긴  작업이  먼저  오면  평균  대기시간이  길어집니<br/>다. SJF는  실행시간이  짧은  작업을  우선  처리하여  평균  대기시간을  최소화하지만 , 실행시간  예측이  어렵고  기아<br/>현상이  발생할  수  있습니다 . RR 은  시분할  방식으로  모든  프로세스에  공정한  CPU 시간을  제공하지만 , 컨텍스트<br/>스위칭  오버헤드가  있습니다 . Priority 스케줄링은  우선순위에  따라  처리하지만  낮은  우선순위  프로세스의  기아<br/>현상이  문제입니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q5: 동기화와  상호배제에  대해  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 동기화는  여러  프로세스나  스레드가  공유  자원에  접근할  때  일관성을  보장하기  위한  메커니즘입니다 . 상호배<br/>제는 한  번에  하나의  프로세스만  임계  영역에  접근할  수  있도록  하는  것입니다 . 구현  방법으로는  뮤텍스 ( 바이너리<br/>세마포어 ), 세마포어 ( 카운팅 ), 모니터  등이  있습니다 . 뮤텍스는  락을  얻은  프로세스만  해제할  수  있고 , 세마포어는<br/>자원의  개수를  관리하며 , 모니터는  고수준  동기화  구조체입니다 .<br/>컴퓨터  구조  관련</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q6: 캐시  메모리의  동작  원리와  종류를  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 캐시  메모리는  CPU 와  주기억장치  사이의  속도  차이를  줄이기  위한  고속  메모리입니다 . 지역성  원리 ( 시간적  지<br/>역성, 공간적  지역성 ) 를  이용해  자주  사용되는  데이터를  저장합니다 . L1, L2, L3 캐시로  계층화되어  있으며 , 레벨이<br/>낮을수록  용량은  작지만  속도가  빠릅니다 . 캐시  히트  시  빠른  접근이  가능하지만 , 캐시  미스  시  메모리에서  데이<br/>터를 가져와야  합니다 . 교체  정책으로는  LRU, FIFO, Random 등이  있습니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q7: CPU 의  파이프라인에  대해  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 파이프라인은  명령어  실행  과정을  여러  단계로  나누어  동시에  처리하여  처리량을  높이는  기술입니다 . 일반적<br/>으로 인출 (Fetch), 해독 (Decode), 실행 (Execute), 메모리  접근 (Memory), 쓰기 (Write-back) 단계로  구성됩니다 .<br/>파이프라인  해저드로는  구조적  해저드 ( 자원  충돌 ), 데이터  해저드 ( 종속성 ), 제어  해저드 ( 분기 ) 가  있으며 , 이를  해결<br/>하기 위해  포워딩 , 분기  예측 , 스톨  등의  기법을  사용합니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q8: 명령어  집합  구조 (ISA) 에  대해  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> ISA는  소프트웨어와  하드웨어  간의  인터페이스로 , CPU 가  인식할  수  있는  명령어들의  집합입니다 . CISC 는  복<br/>잡하고  다양한  명령어를  제공하여  프로그램  크기를  줄일  수  있지만 , 하드웨어가  복잡해집니다 . RISC 는  단순하고<br/>규격화된  명령어를  사용하여  하드웨어가  단순하고  파이프라인에  유리하지만 , 프로그램  크기가  커질  수  있습니다 .<br/>현재는  두  방식의  장점을  결합한  하이브리드  방식이  주로  사용됩니다 .<br/>네트워크  관련</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q9: OSI 7 계층  모델에  대해  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> OSI 7계층은  네트워크  통신을  7 개  계층으로  나누어  표준화한  모델입니다 . 물리계층 (1 층 ) 은  비트  전송 , 데이터<br/>링크계층 (2 층 ) 은  프레임  전송과  오류  검출 , 네트워크계층 (3 층 ) 은  패킷  라우팅 , 전송계층 (4 층 ) 은  종단  간  연결 , 세<br/>션계층 (5 층 ) 은  세션  관리 , 표현계층 (6 층 ) 은  데이터  변환 , 응용계층 (7 층 ) 은  사용자  인터페이스를  담당합니다 . 각  계<br/>층은 독립적이며  하위  계층의  서비스를  사용하여  상위  계층에  서비스를  제공합니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q10: TCP 와  UDP 의  차이점을  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> TCP는  연결  지향  프로토콜로  신뢰성  있는  데이터  전송을  보장합니다 . 3-way handshake 로  연결을  설정하고 ,<br/>순서 보장 , 오류  검출  및  재전송 , 흐름  제어 , 혼잡  제어  기능을  제공합니다 . UDP 는  비연결  지향  프로토콜로  빠른<br/>전송이  특징입니다 . 연결  설정  없이  데이터를  전송하며 , 신뢰성  보장은  없지만  오버헤드가  적어  실시간  통신에  적<br/>합합니다 . TCP는  웹 , 이메일  등에 , UDP 는  DNS, 스트리밍  등에  사용됩니다 .<br/>추가 면접  예상  질문  및  답변<br/>운영체제  심화</p>
  </div>
</details>
  </div>
</details>

<details>
  <summary><span class="accordion-title">추가 면접 예상 질문 및 답변</span> <span class="indicator">펼치기</span></summary>
  <div class="accordion-content">
<details>
  <summary style="font-size:1rem;"><b>Q11: 가상  메모리의  장단점과  페이지  교체  알고리즘을  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 가상  메모리의  장점은  물리  메모리  크기  제한  극복 , 메모리  효율성  향상 , 프로그램  간  메모리  보호입니다 . 단점<br/>은 주소  변환  오버헤드 , 페이지  폴트  시  성능  저하 , 스레싱  발생  가능성입니다 . 페이지  교체  알고리즘으로는<br/>FIFO(구현  간단하지만  성능  보장  안됨 ), LRU( 최적에  가깝지만  구현  복잡 ), LFU( 사용  빈도  기반 ), Clock(LRU 근사 ,<br/>참조 비트  사용 ) 등이  있습니다 . 각각  교체  성능과  구현  복잡도의  트레이드오프가  있습니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q12: 인터럽트와  시스템  콜의  차이점을  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 인터럽트는  하드웨어나  소프트웨어에서  CPU 에게  즉시  처리가  필요한  사건을  알리는  메커니즘입니다 . 하드웨<br/>어 인터럽트 (I/O, 타이머 ) 와  소프트웨어  인터럽트 ( 트랩 , 예외 ) 가  있습니다 . 시스템  콜은  사용자  프로그램이  운영체<br/>제 서비스를  요청하는  인터페이스입니다 . 인터럽트는  비동기적이고  예측  불가능하지만 , 시스템  콜은  프로그램에<br/>서 의도적으로  호출합니다 . 둘  다  모드  전환 ( 유저  모드  → 커널  모드 ) 을  수반합니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q13: 컨텍스트  스위칭이란  무엇이고  성능에  미치는  영향은 ?</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 컨텍스트  스위칭은  CPU 가  현재  실행  중인  프로세스나  스레드를  중단하고  다른  프로세스나  스레드로  실행을<br/>전환하는  과정입니다 . 현재  상태 ( 레지스터 , 프로그램  카운터 , 스택  포인터  등 ) 를  저장하고  새로운  프로세스의  상<br/>태를 복원합니다 . 성능  영향으로는  직접  비용 ( 상태  저장 / 복원  시간 ) 과  간접  비용 ( 캐시  무효화 , TLB 플러시 , 파이프<br/>라인 스톨 )이  있습니다 . 스레드  간  컨텍스트  스위칭이  프로세스  간보다  비용이  적습니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q14: 파일  시스템의  구조와  파일  할당  방법을  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 파일  시스템은  파일과  디렉터리를  저장하고  관리하는  시스템입니다 . 구조는  부트  블록 , 슈퍼  블록 ( 메타데이<br/>터), 아이노드  테이블 ( 파일  속성 ), 데이터  블록으로  구성됩니다 . 파일  할당  방법은  연속  할당 ( 빠른  접근 , 외부  단편<br/>화), 링크  할당 ( 동적  크기 , 순차  접근만  가능 ), 인덱스  할당 ( 직접 / 간접  접근 , 작은  파일에  오버헤드 ) 이  있습니다 . 현<br/>대 파일  시스템은  대부분  인덱스  할당의  변형을  사용합니다 .<br/>컴퓨터  구조  심화</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q15: 메모리  계층구조와  지역성  원리를  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 메모리  계층구조는  속도 , 용량 , 가격을  고려한  메모리  시스템입니다 . CPU 레지스터  → 캐시 (L1, L2, L3) → 주기<br/>억장치  → 보조기억장치  순으로  구성됩니다 . 상위로  갈수록  빠르고  비싸며  용량이  작습니다 . 지역성  원리는  시간<br/>적 지역성 ( 최근  접근한  데이터에  다시  접근 ) 과  공간적  지역성 ( 접근한  데이터  근처  데이터에  접근 ) 으로  나뉩니다 .<br/>이 원리를  활용해  캐시  시스템의  효율성을  높입니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q16: 분기  예측과  추측  실행에  대해  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 분기  예측은  조건부  분기  명령어의  결과를  미리  예측하여  파이프라인  성능을  향상시키는  기술입니다 . 정적  예<br/>측(컴파일러  힌트 ) 과  동적  예측 ( 실행  시  학습 ) 이  있습니다 . 동적  예측은  지역  예측 ( 개별  분기 ), 전역  예측 ( 분기  패<br/>턴), 하이브리드  예측을  사용합니다 . 추측  실행은  예측을  바탕으로  명령어를  미리  실행하되 , 예측이  틀리면  롤백합<br/>니다. 예측  정확도가  높을수록  성능  향상이  크지만 , 틀리면  페널티가  발생합니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q17: 슈퍼스칼라와  VLIW 아키텍처를  비교해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 슈퍼스칼라는  하드웨어가  동적으로  명령어  수준  병렬성을  찾아  여러  명령어를  동시  실행하는  구조입니다 . 아<br/>웃오브오더  실행 , 동적  스케줄링 , 레지스터  리네이밍  등을  사용하며 , 소프트웨어  호환성이  좋지만  하드웨어가  복<br/>잡합니다 . VLIW는  컴파일러가  정적으로  병렬성을  찾아  긴  명령어  워드에  여러  연산을  패킹하는  구조입니다 . 하드<br/>웨어가  단순하고  전력  효율적이지만 , 컴파일러  최적화에  의존하고  코드  호환성이  떨어집니다 .<br/>네트워크  심화</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q18: HTTP/HTTPS 의  차이점과  TLS/SSL 에  대해  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> HTTP는  평문으로  데이터를  전송하는  프로토콜로  보안에  취약합니다 . HTTPS 는  HTTP 에  TLS/SSL 보안  계층을<br/>추가한  것으로 , 암호화 , 무결성 , 인증을  제공합니다 . TLS/SSL 은  핸드셰이크  과정에서  서버  인증서  확인 , 암호화  알<br/>고리즘  협상 , 세션  키  교환을  수행합니다 . 대칭키  암호화로  데이터를  암호화하고 , 비대칭키  암호화로  세션키를  안<br/>전하게  교환합니다 . HTTPS 는  SEO 이점과  사용자  신뢰도  향상  등의  부가  효과도  있습니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q19: 라우팅  알고리즘과  프로토콜을  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> 라우팅  알고리즘은  네트워크에서  최적  경로를  찾는  알고리즘입니다 . 거리  벡터  알고리즘 (RIP) 은  인접  라우터<br/>와 거리  정보를  교환하여  라우팅  테이블을  구축하지만 , 수렴  속도가  느리고  무한  계수  문제가  있습니다 . 링크  상<br/>태 알고리즘 (OSPF) 은  전체  네트워크  토폴로지를  파악하여  최단  경로를  계산하며 , 빠른  수렴과  정확성을  제공하<br/>지만 메모리와  계산  비용이  큽니다 . BGP 는  AS 간  라우팅을  담당하는  외부  게이트웨이  프로토콜입니다 .</p>
  </div>
</details>

<details>
  <summary style="font-size:1rem;"><b>Q20: DNS 의  동작  원리와  레코드  종류를  설명해주세요 .</b></summary>
  <div class="accordion-content">
    <p><b>A:</b> DNS는  도메인  이름을  IP 주소로  변환하는  계층적  분산  데이터베이스  시스템입니다 . 클라이언트가  도메인을<br/>질의하면 , 로컬  DNS 서버가  루트  DNS → TLD DNS → 권한  DNS 순으로  재귀적  또는  반복적  질의를  수행합니다 .<br/>주요 레코드  종류는  A(IPv4 주소 ), AAAA(IPv6 주소 ), CNAME( 별명 ), MX( 메일  서버 ), NS( 네임서버 ), PTR( 역방향<br/>조회), TXT( 텍스트  정보 ) 등이  있습니다 . 캐싱을  통해  성능을  향상시키며 , TTL 로  캐시  유효  시간을  관리합니다 .<br/>시스템  기초  개념  정리<br/>1. 운영체제  (Operating System)<br/>1.1 운영체제  개요<br/>운영체제란 ?<br/>컴퓨터  하드웨어를  관리하고  응용  프로그램과  하드웨어  사이에서  중개  역할을  하는  시스템  소프트웨어입니다 .<br/>운영체제의  역할<br/>자원 관리: CPU, 메모리 , 입출력장치 , 파일  등의  자원을  효율적으로  관리<br/>프로세스  관리: 프로그램의  실행과  종료를  관리<br/>메모리  관리: 주기억장치의  할당과  회수를  관리<br/>파일 시스템  관리: 파일과  디렉터리를  관리<br/>입출력  관리: 입출력  장치와의  상호작용을  관리<br/>사용자  인터페이스  제공: 사용자와  시스템  간의  인터페이스  제공<br/>운영체제의  종류<br/>일괄 처리  시스템: 작업들을  모아서  순차적으로  처리<br/>시분할  시스템: 여러  사용자가  동시에  시스템을  사용<br/>실시간  시스템: 정해진  시간  내에  작업을  완료해야  하는  시스템<br/>분산 시스템: 여러  컴퓨터가  네트워크로  연결된  시스템<br/>다중 프로세서  시스템: 여러  CPU 를  가진  시스템<br/>1.2 프로세스  관리<br/>프로세스  (Process)<br/>실행 중인  프로그램의  인스턴스로 , 프로그램  코드와  관련된  모든  자원을  포함합니다 .<br/>프로세스  상태<br/>생성 (New): 프로세스가  생성되는  상태<br/>준비 (Ready): CPU 할당을  기다리는  상태<br/>실행 (Running): CPU를  할당받아  실행  중인  상태<br/>대기 (Waiting/Blocked): 입출력이나  이벤트를  기다리는  상태<br/>종료 (Terminated): 실행이  완료된  상태<br/>프로세스  제어  블록  (PCB)<br/>운영체제가  프로세스를  관리하기  위해  유지하는  자료구조입니다 .<br/>PCB 구성  요소<br/>프로세스  식별자  (PID)<br/>프로세스  상태<br/>프로그램  카운터<br/>레지스터  정보<br/>메모리  관리  정보<br/>계정 정보<br/>입출력  상태  정보<br/>스레드  (Thread)<br/>프로세스  내에서  실행되는  경량  프로세스로 , 같은  프로세스  내의  스레드들은  주소  공간을  공유합니다 .<br/>스레드의  장점<br/>빠른 생성과  종료<br/>적은 컨텍스트  스위칭  비용<br/>메모리  공유로  인한  통신  용이<br/>병렬 처리  가능<br/>스레드의  단점<br/>동기화  문제<br/>한 스레드의  오류가  전체  프로세스에  영향<br/>디버깅의  어려움<br/>1.3 CPU 스케줄링<br/>CPU 스케줄링이란 ?<br/>여러 프로세스가  CPU 를  사용하려  할  때 , 어떤  프로세스에게  CPU 를  할당할지  결정하는  것입니다 .<br/>스케줄링  목표<br/>CPU 사용률  최대화<br/>처리량  최대화<br/>대기 시간  최소화<br/>응답 시간  최소화<br/>반환 시간  최소화<br/>선점 vs 비선점  스케줄링<br/>비선점  (Non-preemptive): 실행  중인  프로세스가  자발적으로  CPU 를  반납할  때까지  대기<br/>선점 (Preemptive): 운영체제가  강제로  CPU 를  회수할  수  있음<br/>스케줄링  알고리즘<br/>FCFS (First Come First Served)<br/>먼저 온  순서대로  처리<br/>구현이  간단하지만  평균  대기시간이  길  수  있음<br/>비선점  방식<br/>SJF (Shortest Job First)<br/>실행시간이  가장  짧은  작업을  우선  처리<br/>평균 대기시간  최소화<br/>실행시간  예측의  어려움<br/>SRTF (Shortest Remaining Time First)<br/>SJF의  선점  버전<br/>남은 시간이  가장  짧은  프로세스를  우선  실행<br/>Priority Scheduling<br/>우선순위에  따라  CPU 할당<br/>기아 현상  발생  가능<br/>에이징  기법으로  해결<br/>Round Robin (RR)<br/>시분할  방식<br/>각 프로세스에  동일한  시간  할당  (time quantum)<br/>공정하지만  컨텍스트  스위칭  오버헤드<br/>Multi-level Queue<br/>여러 개의  큐를  사용<br/>각 큐마다  다른  스케줄링  알고리즘  적용<br/>프로세스  특성에  따라  큐  배정<br/>Multi-level Feedback Queue<br/>프로세스가  큐  간  이동  가능<br/>동적 우선순위  조정<br/>가장 일반적인  방식<br/>1.4 메모리  관리<br/>메모리  관리  목표<br/>메모리  보호: 프로세스  간  메모리  침범  방지<br/>메모리  공유: 필요에  따른  메모리  공유<br/>가상 주소: 논리  주소를  물리  주소로  변환<br/>메모리  할당: 효율적인  메모리  할당과  해제<br/>주소 바인딩<br/>논리 주소 ( 가상  주소 ) 를  물리  주소로  변환하는  과정입니다 .<br/>바인딩  시점<br/>컴파일  타임: 컴파일  시  절대  주소  결정<br/>로드 타임: 프로그램  로딩  시  주소  결정<br/>실행 타임: 실행  중  주소  변환<br/>연속 메모리  할당<br/>고정 분할<br/>메모리를  고정  크기  파티션으로  분할<br/>내부 단편화  발생<br/>가변 분할<br/>프로세스  크기에  따라  동적  분할<br/>외부 단편화  발생<br/>할당 알고리즘<br/>First Fit: 첫 번째  적절한  공간에  할당<br/>Best Fit: 가장  작은  적절한  공간에  할당<br/>Worst Fit: 가장  큰  공간에  할당<br/>페이징  (Paging)<br/>논리 메모리를  페이지 , 물리  메모리를  프레임으로  나누어  관리하는  방식입니다 .<br/>특징<br/>외부 단편화  해결<br/>내부 단편화  발생  가능  ( 마지막  페이지 )<br/>페이지  테이블을  통한  주소  변환<br/>페이지  테이블<br/>논리 페이지  번호를  물리  프레임  번호로  매핑<br/>각 프로세스마다  고유한  페이지  테이블  보유<br/>TLB (Translation Lookaside Buffer) 로  성능  향상<br/>세그멘테이션  (Segmentation)<br/>프로그램을  논리적  단위 ( 세그먼트 ) 로  나누어  관리하는  방식입니다 .<br/>특징<br/>논리적  구조와  일치<br/>외부 단편화  발생<br/>각 세그먼트마다  다른  크기  가능<br/>가상 메모리  (Virtual Memory)<br/>물리 메모리보다  큰  프로그램을  실행할  수  있도록  하는  기술입니다 .<br/>요구 페이징  (Demand Paging)<br/>필요한  페이지만  메모리에  로드<br/>페이지  폴트  발생  시  디스크에서  로드<br/>지역성  원리  활용<br/>페이지  교체  알고리즘<br/>FIFO: 가장  오래된  페이지  교체<br/>LRU: 가장  오랫동안  사용되지  않은  페이지  교체<br/>LFU: 가장  적게  사용된  페이지  교체<br/>Clock: 참조  비트를  이용한  LRU 근사<br/>스레싱  (Thrashing)<br/>페이지  폴트가  과도하게  발생하는  현상<br/>작업 집합  모델로  방지<br/>지역성  기반  할당으로  해결<br/>1.5 프로세스  동기화<br/>임계 영역  (Critical Section)<br/>여러 프로세스가  공유하는  자원에  접근하는  코드  영역입니다 .<br/>동기화  조건<br/>상호 배제  (Mutual Exclusion): 한 번에  하나의  프로세스만  임계  영역  진입<br/>진행 (Progress): 임계  영역이  비어있으면  진입  요청  프로세스  중  하나는  진입<br/>한정 대기  (Bounded Waiting): 무한  대기  방지<br/>동기화  도구<br/>뮤텍스  (Mutex)<br/>바이너리  세마포어<br/>락을 얻은  스레드만  해제  가능<br/>소유권  개념<br/>세마포어  (Semaphore)<br/>정수형  변수와  두  개의  원자  연산  (P, V)<br/>카운팅  세마포어 : 자원의  개수  관리<br/>바이너리  세마포어 : 상호  배제<br/>모니터  (Monitor)<br/>고수준  동기화  구조체<br/>상호 배제  자동  보장<br/>조건 변수를  통한  대기 / 신호<br/>스핀락  (Spinlock)<br/>바쁜 대기  방식<br/>짧은 임계  영역에  적합<br/>CPU 자원  낭비  가능<br/>데드락  (Deadlock)<br/>두 개  이상의  프로세스가  서로  상대방이  점유한  자원을  기다리며  무한  대기하는  상태입니다 .<br/>발생 조건<br/>1. 상호 배제: 자원을  동시에  사용할  수  없음<br/>2. 점유와  대기: 자원을  가진  채로  다른  자원을  대기<br/>3. 비선점: 강제로  자원을  빼앗을  수  없음<br/>4. 순환 대기: 자원  요청이  원형을  이룸<br/>해결 방법<br/>예방: 4가지  조건  중  하나를  차단<br/>회피: 은행가  알고리즘  등  안전한  상태  유지<br/>탐지와  회복: 데드락  발생  후  탐지하여  해결<br/>무시: 발생  확률이  낮다고  가정  ( 타조  알고리즘 )<br/>1.6 입출력  관리<br/>입출력  장치  분류<br/>블록 장치: 디스크 , 테이프  ( 블록  단위  접근 )<br/>문자 장치: 키보드 , 마우스  ( 문자  단위  접근 )<br/>입출력  제어  방식<br/>폴링 (Polling): CPU가  주기적으로  상태  확인<br/>인터럽트  (Interrupt): 장치가  완료  시  CPU 에  신호<br/>DMA (Direct Memory Access): 메모리  직접  접근<br/>디스크  스케줄링<br/>FCFS: 요청  순서대로  처리<br/>SSTF: 현재  위치에서  가장  가까운  요청  처리<br/>SCAN: 엘리베이터  알고리즘 , 한  방향으로  이동<br/>C-SCAN: 원형  SCAN, 한  방향으로만  서비스<br/>LOOK: 요청이  있는  곳까지만  이동<br/>2. 컴퓨터  구조  (Computer Architecture)<br/>2.1 컴퓨터  구조  개요<br/>폰 노이만  구조<br/>프로그램과  데이터를  동일한  메모리에  저장하는  구조입니다 .<br/>구성 요소<br/>CPU: 중앙  처리  장치<br/>메모리: 프로그램과  데이터  저장<br/>입출력  장치: 외부와의  인터페이스<br/>버스: 구성  요소  간  데이터  전송  경로<br/>하버드  구조<br/>명령어  메모리와  데이터  메모리를  분리한  구조입니다 .<br/>장점<br/>명령어와  데이터  동시  접근  가능<br/>보안성  향상<br/>성능 향상<br/>2.2 CPU 구조<br/>CPU 구성  요소<br/>산술논리연산장치  (ALU): 산술  및  논리  연산  수행<br/>제어장치: 명령어  해독  및  제어  신호  생성<br/>레지스터: 고속  저장  공간<br/>레지스터  종류<br/>프로그램  카운터  (PC): 다음  실행할  명령어  주소<br/>명령어  레지스터  (IR): 현재  실행  중인  명령어<br/>누적기  (ACC): 연산  결과  저장<br/>인덱스  레지스터: 주소  계산에  사용<br/>스택 포인터: 스택의  최상위  주소<br/>상태 레지스터: 플래그  비트  저장<br/>명령어  실행  사이클<br/>1. 인출 (Fetch): 메모리에서  명령어  읽기<br/>2. 해독 (Decode): 명령어  분석<br/>3. 실행 (Execute): 연산  수행<br/>4. 저장 (Store): 결과  저장<br/>2.3 메모리  계층구조<br/>메모리  계층<br/>레지스터: 가장  빠름 , 용량  작음<br/>캐시 메모리: 빠름 , 중간  용량<br/>주기억장치: 중간  속도 , 큰  용량<br/>보조기억장치: 느림 , 매우  큰  용량<br/>캐시 메모리<br/>CPU와  주기억장치  사이의  고속  버퍼  메모리입니다 .<br/>지역성  원리<br/>시간적  지역성: 최근  접근한  데이터에  다시  접근할  가능성이  높음<br/>공간적  지역성: 접근한  데이터  근처의  데이터에  접근할  가능성이  높음<br/>캐시 레벨<br/>L1 캐시: CPU 코어에  내장 , 가장  빠름<br/>L2 캐시: CPU 패키지  내부 , 중간  속도<br/>L3 캐시: 여러  코어가  공유 , 큰  용량<br/>캐시 매핑<br/>직접 매핑: 각 블록이  한  캐시  라인에만  매핑<br/>연관 매핑: 임의의  캐시  라인에  매핑  가능<br/>세트 연관  매핑: 여러  세트로  나누어  부분  연관<br/>교체 정책<br/>LRU: 가장  오래  사용하지  않은  블록  교체<br/>FIFO: 가장  먼저  들어온  블록  교체<br/>Random: 임의  블록  교체<br/>2.4 파이프라인<br/>파이프라인이란 ?<br/>명령어  처리  과정을  여러  단계로  나누어  동시에  처리하는  기법입니다 .<br/>5단계  파이프라인<br/>1. IF (Instruction Fetch): 명령어  인출<br/>2. ID (Instruction Decode): 명령어  해독<br/>3. EX (Execute): 실행<br/>4. MEM (Memory Access): 메모리  접근<br/>5. WB (Write Back): 결과  저장<br/>파이프라인  해저드<br/>구조적  해저드  (Structural Hazard)<br/>하드웨어  자원  충돌<br/>해결: 자원  추가 , 파이프라인  스톨<br/>데이터  해저드  (Data Hazard)<br/>명령어  간  데이터  의존성<br/>RAW, WAR, WAW 해저드<br/>해결: 포워딩 , 스톨 , 아웃오브오더  실행<br/>제어 해저드  (Control Hazard)<br/>분기 명령어로  인한  파이프라인  플러시<br/>해결: 분기  예측 , 지연  슬롯<br/>2.5 명령어  집합  구조  (ISA)<br/>CISC vs RISC<br/>CISC (Complex Instruction Set Computer)<br/>복잡하고  다양한  명령어<br/>가변 길이  명령어<br/>적은 레지스터<br/>마이크로프로그래밍<br/>예: x86<br/>RISC (Reduced Instruction Set Computer)<br/>단순하고  규격화된  명령어<br/>고정 길이  명령어<br/>많은 레지스터<br/>하드와이어드  제어<br/>예: ARM, MIPS<br/>주소 지정  방식<br/>즉시 주소법: 오퍼랜드가  명령어  내에  포함<br/>직접 주소법: 오퍼랜드가  메모리  주소<br/>간접 주소법: 메모리에  있는  주소를  참조<br/>레지스터  주소법: 레지스터  내의  값  사용<br/>인덱스  주소법: 베이스  주소  + 인덱스<br/>2.6 병렬  처리<br/>병렬성  분류<br/>명령어  수준  병렬성  (ILP): 명령어  간  병렬  실행<br/>스레드  수준  병렬성  (TLP): 스레드  간  병렬  실행<br/>프로세스  수준  병렬성: 프로세스  간  병렬  실행<br/>멀티프로세서  시스템<br/>공유 메모리  (UMA/NUMA)<br/>UMA: 모든  프로세서가  메모리에  균등하게  접근<br/>NUMA: 로컬  메모리에  빠르게  접근<br/>분산 메모리<br/>각 프로세서가  독립적인  메모리<br/>메시지  전달로  통신<br/>멀티코어  프로세서<br/>하나의  칩에  여러  CPU 코어<br/>캐시 공유  및  일관성  문제<br/>스레드  수준  병렬성  활용<br/>3. 네트워크  기초<br/>3.1 네트워크  개요<br/>네트워크란 ?<br/>컴퓨터나  다른  장치들을  연결하여  데이터를  공유할  수  있게  하는  시스템입니다 .<br/>네트워크  분류<br/>규모별<br/>PAN: 개인  영역  네트워크<br/>LAN: 근거리  통신망<br/>MAN: 도시권  통신망<br/>WAN: 광역  통신망<br/>전송 방식별<br/>유니캐스트: 1:1 통신<br/>브로드캐스트: 1:모든  수신자  통신<br/>멀티캐스트: 1:특정  그룹  통신<br/>토폴로지별<br/>버스형: 하나의  통신선에  모든  노드  연결<br/>스타형: 중앙  허브에  모든  노드  연결<br/>링형: 노드들이  원형으로  연결<br/>트리형: 계층적  구조<br/>메시형: 모든  노드가  서로  연결<br/>3.2 OSI 7 계층  모델<br/>1계층 : 물리  계층  (Physical Layer)<br/>기능: 비트  스트림을  전기적 / 광학적  신호로  변환<br/>장비: 허브 , 리피터 , 케이블<br/>프로토콜: RS-232, RJ-45<br/>2계층 : 데이터링크  계층  (Data Link Layer)<br/>기능: 프레임  단위  전송 , 오류  검출 / 정정 , 흐름  제어<br/>장비: 스위치 , 브릿지<br/>프로토콜: Ethernet, PPP, HDLC<br/>3계층 : 네트워크  계층  (Network Layer)<br/>기능: 패킷  라우팅 , 경로  결정<br/>장비: 라우터 , L3 스위치<br/>프로토콜: IP, ICMP, OSPF, BGP<br/>4계층 : 전송  계층  (Transport Layer)<br/>기능: 종단  간  통신 , 신뢰성  보장 , 포트  관리<br/>프로토콜: TCP, UDP<br/>5계층 : 세션  계층  (Session Layer)<br/>기능: 세션  설정 / 관리 / 종료<br/>프로토콜: NetBIOS, RPC<br/>6계층 : 표현  계층  (Presentation Layer)<br/>기능: 데이터  암호화 / 복호화 , 압축 , 형식  변환<br/>프로토콜: SSL/TLS, JPEG, MPEG<br/>7계층 : 응용  계층  (Application Layer)<br/>기능: 사용자  인터페이스 , 네트워크  서비스  제공<br/>프로토콜: HTTP, FTP, SMTP, DNS<br/>3.3 TCP/IP 모델<br/>TCP/IP 4 계층<br/>1. 네트워크  인터페이스  계층: OSI 1, 2 계층<br/>2. 인터넷  계층: OSI 3계층  (IP)<br/>3. 전송 계층: OSI 4계층  (TCP, UDP)<br/>4. 응용 계층: OSI 5, 6, 7 계층<br/>IP 주소<br/>네트워크에서  장치를  식별하는  고유한  주소입니다 .<br/>IPv4<br/>32비트  주소  (4 옥텟 )<br/>점분 십진법  표기  ( 예 : 192.168.1.1)<br/>주소 부족  문제<br/>IPv6<br/>128비트  주소<br/>16진법  표기  ( 예 : 2001:db8::1)<br/>주소 공간  확장<br/>주소 클래스  (IPv4)<br/>A클래스: 1.0.0.0 ~ 126.0.0.0 ( 대규모  네트워크 )<br/>B클래스: 128.0.0.0 ~ 191.255.0.0 ( 중규모  네트워크 )<br/>C클래스: 192.0.0.0 ~ 223.255.255.0 ( 소규모  네트워크 )<br/>서브넷팅<br/>네트워크를  작은  단위로  분할<br/>서브넷  마스크  사용<br/>CIDR 표기법  ( 예 : 192.168.1.0/24)<br/>3.4 주요  프로토콜<br/>TCP (Transmission Control Protocol)<br/>연결 지향적이고  신뢰성  있는  데이터  전송  프로토콜입니다 .<br/>특징<br/>연결 설정  (3-way handshake)<br/>순서 보장<br/>오류 검출  및  재전송<br/>흐름 제어<br/>혼잡 제어<br/>3-way Handshake<br/>1. 클라이언트  → 서버 : SYN<br/>2. 서버 → 클라이언트 : SYN+ACK<br/>3. 클라이언트  → 서버 : ACK<br/>4-way Handshake ( 연결  종료 )<br/>1. 클라이언트  → 서버 : FIN<br/>2. 서버 → 클라이언트 : ACK<br/>3. 서버 → 클라이언트 : FIN<br/>4. 클라이언트  → 서버 : ACK<br/>UDP (User Datagram Protocol)<br/>비연결  지향적이고  빠른  데이터  전송  프로토콜입니다 .<br/>특징<br/>연결 설정  없음<br/>순서 보장  없음<br/>신뢰성  보장  없음<br/>낮은 오버헤드<br/>실시간  통신에  적합<br/>HTTP (HyperText Transfer Protocol)<br/>웹에서  정보를  주고받기  위한  프로토콜입니다 .<br/>특징<br/>요청-응답  모델<br/>무상태  (Stateless)<br/>TCP 기반<br/>HTTP 메서드<br/>GET: 리소스  조회<br/>POST: 데이터  전송<br/>PUT: 리소스  수정<br/>DELETE: 리소스  삭제<br/>HEAD: 헤더  정보만  조회<br/>OPTIONS: 서버  옵션  조회<br/>HTTP 상태  코드<br/>1xx: 정보성  응답<br/>2xx: 성공  (200 OK)<br/>3xx: 리다이렉션  (301 Moved Permanently)<br/>4xx: 클라이언트  오류  (404 Not Found)<br/>5xx: 서버  오류  (500 Internal Server Error)<br/>HTTPS (HTTP Secure)<br/>HTTP에  SSL/TLS 보안  계층을  추가한  프로토콜입니다 .<br/>특징<br/>데이터  암호화<br/>서버 인증<br/>데이터  무결성  보장<br/>3.5 네트워크  장비<br/>허브 (Hub)<br/>1계층  장비<br/>모든 포트에  데이터  브로드캐스트<br/>반이중  통신<br/>충돌 도메인  공유<br/>스위치  (Switch)<br/>2계층  장비<br/>MAC 주소  학습<br/>전이중  통신<br/>충돌 도메인  분리<br/>라우터  (Router)<br/>3계층  장비<br/>IP 주소  기반  경로  결정<br/>브로드캐스트  도메인  분리<br/>서로 다른  네트워크  간  통신<br/>게이트웨이  (Gateway)<br/>서로 다른  프로토콜  간  변환<br/>네트워크  간  중개  역할<br/>3.6 라우팅<br/>라우팅이란 ?<br/>패킷이  목적지까지  가는  최적의  경로를  결정하는  과정입니다 .<br/>라우팅  테이블<br/>목적지  네트워크<br/>다음 홉  (Next Hop)<br/>메트릭  (비용 )<br/>인터페이스<br/>라우팅  프로토콜<br/>내부 게이트웨이  프로토콜  (IGP)<br/>RIP: 거리  벡터 , 홉  수  기준<br/>OSPF: 링크  상태 , 최단  경로  우선<br/>EIGRP: 하이브리드 , 대역폭과  지연  고려<br/>외부 게이트웨이  프로토콜  (EGP)<br/>BGP: 자율  시스템  간  라우팅 , 정책  기반<br/>3.7 DNS (Domain Name System)<br/>DNS란 ?<br/>도메인  이름을  IP 주소로  변환하는  분산  데이터베이스  시스템입니다 .<br/>DNS 구조<br/>루트 도메인: 최상위  (.)<br/>TLD (Top Level Domain): .com, .org, .net 등<br/>2차 도메인: google, naver 등<br/>서브 도메인: www, mail 등<br/>DNS 레코드  타입<br/>IPv4 주소<br/>AAAA: IPv6 주소<br/>CNAME: 별칭<br/>MX: 메일  서버<br/>NS: 네임  서버<br/>PTR: 역방향  조회<br/>TXT: 텍스트  정보<br/>DNS 조회  과정<br/>1. 로컬 DNS 서버에  질의<br/>2. 루트 DNS 서버  조회<br/>3. TLD DNS 서버  조회<br/>4. 권한 DNS 서버  조회<br/>5. IP 주소  반환<br/>4. 보안  기초<br/>4.1 정보보안  3 요소<br/>기밀성  (Confidentiality)<br/>인가된  사용자만  정보에  접근<br/>암호화 , 접근  제어<br/>무결성  (Integrity)<br/>정보의  정확성과  완전성  보장<br/>해시 함수 , 디지털  서명<br/>가용성  (Availability)<br/>필요할  때  정보에  접근  가능<br/>이중화 , 백업<br/>4.2 암호화<br/>대칭키  암호화<br/>암호화와  복호화에  같은  키  사용<br/>빠른 처리  속도<br/>키 관리의  어려움<br/>예: AES, DES<br/>비대칭키  암호화<br/>공개키와  개인키  쌍  사용<br/>키 교환  문제  해결<br/>느린 처리  속도<br/>예: RSA, ECC<br/>해시 함수<br/>임의 길이  데이터를  고정  길이로  변환<br/>일방향  함수<br/>무결성  검증에  사용<br/>예: SHA-256, MD5<br/>4.3 네트워크  보안<br/>방화벽  (Firewall)<br/>네트워크  접근  제어<br/>패킷 필터링<br/>상태 추적<br/>애플리케이션  게이트웨이<br/>IDS/IPS<br/>IDS: 침입  탐지  시스템<br/>IPS: 침입  방지  시스템<br/>시그니처  기반  / 행위  기반<br/>VPN (Virtual Private Network)<br/>공개 네트워크를  통한  안전한  통신<br/>터널링 , 암호화<br/>Site-to-Site, Remote Access<br/>5. 시스템  성능  평가<br/>5.1 성능  지표<br/>처리량  (Throughput)<br/>단위 시간당  처리된  작업  수<br/>TPS (Transaction Per Second)<br/>응답 시간  (Response Time)<br/>요청부터  응답까지  걸리는  시간<br/>대기 시간  + 처리  시간<br/>사용률  (Utilization)<br/>자원이  사용된  시간  비율<br/>CPU 사용률 , 메모리  사용률<br/>처리능력  (Capacity)<br/>시스템이  처리할  수  있는  최대  부하<br/>5.2 병목  현상<br/>병목 현상이란 ?<br/>시스템에서  가장  느린  구성  요소가  전체  성능을  제한하는  현상입니다 .<br/>병목점  식별<br/>성능 모니터링<br/>프로파일링<br/>부하 테스트<br/>해결 방법<br/>하드웨어  업그레이드<br/>알고리즘  최적화<br/>아키텍처  개선<br/>로드 밸런싱<br/>5.3 확장성<br/>수직 확장  (Scale Up)<br/>단일 시스템의  성능  향상<br/>CPU, 메모리  증설<br/>한계가  명확함<br/>수평 확장  (Scale Out)<br/>시스템  수  증가<br/>분산 처리<br/>무제한  확장  가능<br/>복잡성  증가</p>
  </div>
</details>
  </div>
</details>

<details>
  <summary><span class="accordion-title">시스템 기초 개념 정리 (전체)</span> <span class="indicator">펼치기</span></summary>
  <div class="accordion-content">
<ol>
<li>운영체제  (Operating System)</li>
</ol>
<h2>1.1 운영체제  개요</h2>
<p>운영체제란 ? 컴퓨터  하드웨어를  관리하고  응용  프로그램과  하드웨어  사이에서  중개  역할을  하는  시스템  소프트웨어입니다 . 운영체제의  역할 자원 관리: CPU, 메모리 , 입출력장치 , 파일  등의  자원을  효율적으로  관리 프로세스  관리: 프로그램의  실행과  종료를  관리 메모리  관리: 주기억장치의  할당과  회수를  관리 파일 시스템  관리: 파일과  디렉터리를  관리 입출력  관리: 입출력  장치와의  상호작용을  관리 사용자  인터페이스  제공: 사용자와  시스템  간의  인터페이스  제공 운영체제의  종류 일괄 처리  시스템: 작업들을  모아서  순차적으로  처리 시분할  시스템: 여러  사용자가  동시에  시스템을  사용 실시간  시스템: 정해진  시간  내에  작업을  완료해야  하는  시스템 분산 시스템: 여러  컴퓨터가  네트워크로  연결된  시스템 다중 프로세서  시스템: 여러  CPU 를  가진  시스템</p>
<h2>1.2 프로세스  관리</h2>
<p>프로세스  (Process) 실행 중인  프로그램의  인스턴스로 , 프로그램  코드와  관련된  모든  자원을  포함합니다 . 프로세스  상태 생성 (New): 프로세스가  생성되는  상태 준비 (Ready): CPU 할당을  기다리는  상태 실행 (Running): CPU를  할당받아  실행  중인  상태 대기 (Waiting/Blocked): 입출력이나  이벤트를  기다리는  상태 종료 (Terminated): 실행이  완료된  상태 프로세스  제어  블록  (PCB) 운영체제가  프로세스를  관리하기  위해  유지하는  자료구조입니다 . PCB 구성  요소 프로세스  식별자  (PID) 프로세스  상태 프로그램  카운터 레지스터  정보 메모리  관리  정보 계정 정보 입출력  상태  정보 스레드  (Thread) 프로세스  내에서  실행되는  경량  프로세스로 , 같은  프로세스  내의  스레드들은  주소  공간을  공유합니다 . 스레드의  장점 빠른 생성과  종료 적은 컨텍스트  스위칭  비용 메모리  공유로  인한  통신  용이 병렬 처리  가능 스레드의  단점 동기화  문제 한 스레드의  오류가  전체  프로세스에  영향 디버깅의  어려움</p>
<h2>1.3 CPU 스케줄링</h2>
<p>CPU 스케줄링이란 ? 여러 프로세스가  CPU 를  사용하려  할  때 , 어떤  프로세스에게  CPU 를  할당할지  결정하는  것입니다 . 스케줄링  목표 CPU 사용률  최대화 처리량  최대화 대기 시간  최소화 응답 시간  최소화 반환 시간  최소화 선점 vs 비선점  스케줄링 비선점  (Non-preemptive): 실행  중인  프로세스가  자발적으로  CPU 를  반납할  때까지  대기 선점 (Preemptive): 운영체제가  강제로  CPU 를  회수할  수  있음 스케줄링  알고리즘 FCFS (First Come First Served) 먼저 온  순서대로  처리 구현이  간단하지만  평균  대기시간이  길  수  있음 비선점  방식 SJF (Shortest Job First) 실행시간이  가장  짧은  작업을  우선  처리 평균 대기시간  최소화 실행시간  예측의  어려움 SRTF (Shortest Remaining Time First) SJF의  선점  버전 남은 시간이  가장  짧은  프로세스를  우선  실행 Priority Scheduling 우선순위에  따라  CPU 할당 기아 현상  발생  가능 에이징  기법으로  해결 Round Robin (RR) 시분할  방식 각 프로세스에  동일한  시간  할당  (time quantum) 공정하지만  컨텍스트  스위칭  오버헤드 Multi-level Queue 여러 개의  큐를  사용 각 큐마다  다른  스케줄링  알고리즘  적용 프로세스  특성에  따라  큐  배정 Multi-level Feedback Queue 프로세스가  큐  간  이동  가능 동적 우선순위  조정 가장 일반적인  방식</p>
<h2>1.4 메모리  관리</h2>
<p>메모리  관리  목표 메모리  보호: 프로세스  간  메모리  침범  방지 메모리  공유: 필요에  따른  메모리  공유 가상 주소: 논리  주소를  물리  주소로  변환 메모리  할당: 효율적인  메모리  할당과  해제 주소 바인딩 논리 주소 ( 가상  주소 ) 를  물리  주소로  변환하는  과정입니다 . 바인딩  시점 컴파일  타임: 컴파일  시  절대  주소  결정 로드 타임: 프로그램  로딩  시  주소  결정 실행 타임: 실행  중  주소  변환 연속 메모리  할당 고정 분할 메모리를  고정  크기  파티션으로  분할 내부 단편화  발생 가변 분할 프로세스  크기에  따라  동적  분할 외부 단편화  발생 할당 알고리즘 First Fit: 첫 번째  적절한  공간에  할당 Best Fit: 가장  작은  적절한  공간에  할당 Worst Fit: 가장  큰  공간에  할당 페이징  (Paging) 논리 메모리를  페이지 , 물리  메모리를  프레임으로  나누어  관리하는  방식입니다 . 특징 외부 단편화  해결 내부 단편화  발생  가능  ( 마지막  페이지 ) 페이지  테이블을  통한  주소  변환 페이지  테이블 논리 페이지  번호를  물리  프레임  번호로  매핑 각 프로세스마다  고유한  페이지  테이블  보유 TLB (Translation Lookaside Buffer) 로  성능  향상 세그멘테이션  (Segmentation) 프로그램을  논리적  단위 ( 세그먼트 ) 로  나누어  관리하는  방식입니다 . 특징 논리적  구조와  일치 외부 단편화  발생 각 세그먼트마다  다른  크기  가능 가상 메모리  (Virtual Memory) 물리 메모리보다  큰  프로그램을  실행할  수  있도록  하는  기술입니다 . 요구 페이징  (Demand Paging) 필요한  페이지만  메모리에  로드 페이지  폴트  발생  시  디스크에서  로드 지역성  원리  활용 페이지  교체  알고리즘 FIFO: 가장  오래된  페이지  교체 LRU: 가장  오랫동안  사용되지  않은  페이지  교체 LFU: 가장  적게  사용된  페이지  교체 Clock: 참조  비트를  이용한  LRU 근사 스레싱  (Thrashing) 페이지  폴트가  과도하게  발생하는  현상 작업 집합  모델로  방지 지역성  기반  할당으로  해결</p>
<h2>1.5 프로세스  동기화</h2>
<p>임계 영역  (Critical Section) 여러 프로세스가  공유하는  자원에  접근하는  코드  영역입니다 . 동기화  조건 상호 배제  (Mutual Exclusion): 한 번에  하나의  프로세스만  임계  영역  진입 진행 (Progress): 임계  영역이  비어있으면  진입  요청  프로세스  중  하나는  진입 한정 대기  (Bounded Waiting): 무한  대기  방지 동기화  도구 뮤텍스  (Mutex) 바이너리  세마포어 락을 얻은  스레드만  해제  가능 소유권  개념 세마포어  (Semaphore) 정수형  변수와  두  개의  원자  연산  (P, V) 카운팅  세마포어 : 자원의  개수  관리 바이너리  세마포어 : 상호  배제 모니터  (Monitor) 고수준  동기화  구조체 상호 배제  자동  보장 조건 변수를  통한  대기 / 신호 스핀락  (Spinlock) 바쁜 대기  방식 짧은 임계  영역에  적합 CPU 자원  낭비  가능 데드락  (Deadlock) 두 개  이상의  프로세스가  서로  상대방이  점유한  자원을  기다리며  무한  대기하는  상태입니다 . 발생 조건</p>
<ol>
<li>상호 배제: 자원을  동시에  사용할  수  없음</li>
<li>점유와  대기: 자원을  가진  채로  다른  자원을  대기</li>
<li>비선점: 강제로  자원을  빼앗을  수  없음</li>
<li>순환 대기: 자원  요청이  원형을  이룸</li>
</ol>
<p>해결 방법 예방: 4가지  조건  중  하나를  차단 회피: 은행가  알고리즘  등  안전한  상태  유지 탐지와  회복: 데드락  발생  후  탐지하여  해결 무시: 발생  확률이  낮다고  가정  ( 타조  알고리즘 )</p>
<h2>1.6 입출력  관리</h2>
<p>입출력  장치  분류 블록 장치: 디스크 , 테이프  ( 블록  단위  접근 ) 문자 장치: 키보드 , 마우스  ( 문자  단위  접근 ) 입출력  제어  방식 폴링 (Polling): CPU가  주기적으로  상태  확인 인터럽트  (Interrupt): 장치가  완료  시  CPU 에  신호 DMA (Direct Memory Access): 메모리  직접  접근 디스크  스케줄링 FCFS: 요청  순서대로  처리 SSTF: 현재  위치에서  가장  가까운  요청  처리 SCAN: 엘리베이터  알고리즘 , 한  방향으로  이동 C-SCAN: 원형  SCAN, 한  방향으로만  서비스 LOOK: 요청이  있는  곳까지만  이동</p>
<ol>
<li>컴퓨터  구조  (Computer Architecture)</li>
</ol>
<h2>2.1 컴퓨터  구조  개요</h2>
<p>폰 노이만  구조 프로그램과  데이터를  동일한  메모리에  저장하는  구조입니다 . 구성 요소 CPU: 중앙  처리  장치 메모리: 프로그램과  데이터  저장 입출력  장치: 외부와의  인터페이스 버스: 구성  요소  간  데이터  전송  경로 하버드  구조 명령어  메모리와  데이터  메모리를  분리한  구조입니다 . 장점 명령어와  데이터  동시  접근  가능 보안성  향상 성능 향상</p>
<h2>2.2 CPU 구조</h2>
<p>CPU 구성  요소 산술논리연산장치  (ALU): 산술  및  논리  연산  수행 제어장치: 명령어  해독  및  제어  신호  생성 레지스터: 고속  저장  공간 레지스터  종류 프로그램  카운터  (PC): 다음  실행할  명령어  주소 명령어  레지스터  (IR): 현재  실행  중인  명령어 누적기  (ACC): 연산  결과  저장 인덱스  레지스터: 주소  계산에  사용 스택 포인터: 스택의  최상위  주소 상태 레지스터: 플래그  비트  저장 명령어  실행  사이클</p>
<ol>
<li>인출 (Fetch): 메모리에서  명령어  읽기</li>
<li>해독 (Decode): 명령어  분석</li>
<li>실행 (Execute): 연산  수행</li>
<li>저장 (Store): 결과  저장</li>
</ol>
<h2>2.3 메모리  계층구조</h2>
<p>메모리  계층 레지스터: 가장  빠름 , 용량  작음 캐시 메모리: 빠름 , 중간  용량 주기억장치: 중간  속도 , 큰  용량 보조기억장치: 느림 , 매우  큰  용량 캐시 메모리 CPU와  주기억장치  사이의  고속  버퍼  메모리입니다 . 지역성  원리 시간적  지역성: 최근  접근한  데이터에  다시  접근할  가능성이  높음 공간적  지역성: 접근한  데이터  근처의  데이터에  접근할  가능성이  높음 캐시 레벨 L1 캐시: CPU 코어에  내장 , 가장  빠름 L2 캐시: CPU 패키지  내부 , 중간  속도 L3 캐시: 여러  코어가  공유 , 큰  용량 캐시 매핑 직접 매핑: 각 블록이  한  캐시  라인에만  매핑 연관 매핑: 임의의  캐시  라인에  매핑  가능 세트 연관  매핑: 여러  세트로  나누어  부분  연관 교체 정책 LRU: 가장  오래  사용하지  않은  블록  교체 FIFO: 가장  먼저  들어온  블록  교체 Random: 임의  블록  교체</p>
<h2>2.4 파이프라인</h2>
<p>파이프라인이란 ? 명령어  처리  과정을  여러  단계로  나누어  동시에  처리하는  기법입니다 . 5단계  파이프라인</p>
<ol>
<li>IF (Instruction Fetch): 명령어  인출</li>
<li>ID (Instruction Decode): 명령어  해독</li>
<li>EX (Execute): 실행</li>
<li>MEM (Memory Access): 메모리  접근</li>
<li>WB (Write Back): 결과  저장</li>
</ol>
<p>파이프라인  해저드 구조적  해저드  (Structural Hazard) 하드웨어  자원  충돌 해결: 자원  추가 , 파이프라인  스톨 데이터  해저드  (Data Hazard) 명령어  간  데이터  의존성 RAW, WAR, WAW 해저드 해결: 포워딩 , 스톨 , 아웃오브오더  실행 제어 해저드  (Control Hazard) 분기 명령어로  인한  파이프라인  플러시 해결: 분기  예측 , 지연  슬롯</p>
<h2>2.5 명령어  집합  구조  (ISA)</h2>
<p>CISC vs RISC CISC (Complex Instruction Set Computer) 복잡하고  다양한  명령어 가변 길이  명령어 적은 레지스터 마이크로프로그래밍 예: x86 RISC (Reduced Instruction Set Computer) 단순하고  규격화된  명령어 고정 길이  명령어 많은 레지스터 하드와이어드  제어 예: ARM, MIPS 주소 지정  방식 즉시 주소법: 오퍼랜드가  명령어  내에  포함 직접 주소법: 오퍼랜드가  메모리  주소 간접 주소법: 메모리에  있는  주소를  참조 레지스터  주소법: 레지스터  내의  값  사용 인덱스  주소법: 베이스  주소  + 인덱스</p>
<h2>2.6 병렬  처리</h2>
<p>병렬성  분류 명령어  수준  병렬성  (ILP): 명령어  간  병렬  실행 스레드  수준  병렬성  (TLP): 스레드  간  병렬  실행 프로세스  수준  병렬성: 프로세스  간  병렬  실행 멀티프로세서  시스템 공유 메모리  (UMA/NUMA) UMA: 모든  프로세서가  메모리에  균등하게  접근 NUMA: 로컬  메모리에  빠르게  접근 분산 메모리 각 프로세서가  독립적인  메모리 메시지  전달로  통신 멀티코어  프로세서 하나의  칩에  여러  CPU 코어 캐시 공유  및  일관성  문제 스레드  수준  병렬성  활용</p>
<ol>
<li>네트워크  기초</li>
</ol>
<h2>3.1 네트워크  개요</h2>
<p>네트워크란 ? 컴퓨터나  다른  장치들을  연결하여  데이터를  공유할  수  있게  하는  시스템입니다 . 네트워크  분류 규모별 PAN: 개인  영역  네트워크 LAN: 근거리  통신망 MAN: 도시권  통신망 WAN: 광역  통신망 전송 방식별 유니캐스트: 1:1 통신 브로드캐스트: 1:모든  수신자  통신 멀티캐스트: 1:특정  그룹  통신 토폴로지별 버스형: 하나의  통신선에  모든  노드  연결 스타형: 중앙  허브에  모든  노드  연결 링형: 노드들이  원형으로  연결 트리형: 계층적  구조 메시형: 모든  노드가  서로  연결</p>
<h2>3.2 OSI 7 계층  모델</h2>
<p>1계층 : 물리  계층  (Physical Layer) 기능: 비트  스트림을  전기적 / 광학적  신호로  변환 장비: 허브 , 리피터 , 케이블 프로토콜: RS-232, RJ-45 2계층 : 데이터링크  계층  (Data Link Layer) 기능: 프레임  단위  전송 , 오류  검출 / 정정 , 흐름  제어 장비: 스위치 , 브릿지 프로토콜: Ethernet, PPP, HDLC 3계층 : 네트워크  계층  (Network Layer) 기능: 패킷  라우팅 , 경로  결정 장비: 라우터 , L3 스위치 프로토콜: IP, ICMP, OSPF, BGP 4계층 : 전송  계층  (Transport Layer) 기능: 종단  간  통신 , 신뢰성  보장 , 포트  관리 프로토콜: TCP, UDP 5계층 : 세션  계층  (Session Layer) 기능: 세션  설정 / 관리 / 종료 프로토콜: NetBIOS, RPC 6계층 : 표현  계층  (Presentation Layer) 기능: 데이터  암호화 / 복호화 , 압축 , 형식  변환 프로토콜: SSL/TLS, JPEG, MPEG 7계층 : 응용  계층  (Application Layer) 기능: 사용자  인터페이스 , 네트워크  서비스  제공 프로토콜: HTTP, FTP, SMTP, DNS</p>
<h2>3.3 TCP/IP 모델</h2>
<p>TCP/IP 4 계층</p>
<ol>
<li>네트워크  인터페이스  계층: OSI 1, 2 계층</li>
<li>인터넷  계층: OSI 3계층  (IP)</li>
<li>전송 계층: OSI 4계층  (TCP, UDP)</li>
<li>응용 계층: OSI 5, 6, 7 계층</li>
</ol>
<p>IP 주소 네트워크에서  장치를  식별하는  고유한  주소입니다 . IPv4 32비트  주소  (4 옥텟 ) 점분 십진법  표기  ( 예 : 192.168.1.1) 주소 부족  문제 IPv6 128비트  주소 16진법  표기  ( 예 : 2001:db8::1) 주소 공간  확장 주소 클래스  (IPv4) A클래스: 1.0.0.0 ~ 126.0.0.0 ( 대규모  네트워크 ) B클래스: 128.0.0.0 ~ 191.255.0.0 ( 중규모  네트워크 ) C클래스: 192.0.0.0 ~ 223.255.255.0 ( 소규모  네트워크 ) 서브넷팅 네트워크를  작은  단위로  분할 서브넷  마스크  사용 CIDR 표기법  ( 예 : 192.168.1.0/24)</p>
<h2>3.4 주요  프로토콜</h2>
<p>TCP (Transmission Control Protocol) 연결 지향적이고  신뢰성  있는  데이터  전송  프로토콜입니다 . 특징 연결 설정  (3-way handshake) 순서 보장 오류 검출  및  재전송 흐름 제어 혼잡 제어 3-way Handshake</p>
<ol>
<li>클라이언트  → 서버 : SYN</li>
<li>서버 → 클라이언트 : SYN+ACK</li>
<li>클라이언트  → 서버 : ACK</li>
</ol>
<p>4-way Handshake ( 연결  종료 )</p>
<ol>
<li>클라이언트  → 서버 : FIN</li>
<li>서버 → 클라이언트 : ACK</li>
<li>서버 → 클라이언트 : FIN</li>
<li>클라이언트  → 서버 : ACK</li>
</ol>
<p>UDP (User Datagram Protocol) 비연결  지향적이고  빠른  데이터  전송  프로토콜입니다 . 특징 연결 설정  없음 순서 보장  없음 신뢰성  보장  없음 낮은 오버헤드 실시간  통신에  적합 HTTP (HyperText Transfer Protocol) 웹에서  정보를  주고받기  위한  프로토콜입니다 . 특징 요청-응답  모델 무상태  (Stateless) TCP 기반 HTTP 메서드 GET: 리소스  조회 POST: 데이터  전송 PUT: 리소스  수정 DELETE: 리소스  삭제 HEAD: 헤더  정보만  조회 OPTIONS: 서버  옵션  조회 HTTP 상태  코드 1xx: 정보성  응답 2xx: 성공  (200 OK) 3xx: 리다이렉션  (301 Moved Permanently) 4xx: 클라이언트  오류  (404 Not Found) 5xx: 서버  오류  (500 Internal Server Error) HTTPS (HTTP Secure) HTTP에  SSL/TLS 보안  계층을  추가한  프로토콜입니다 . 특징 데이터  암호화 서버 인증 데이터  무결성  보장</p>
<h2>3.5 네트워크  장비</h2>
<p>허브 (Hub) 1계층  장비 모든 포트에  데이터  브로드캐스트 반이중  통신 충돌 도메인  공유 스위치  (Switch) 2계층  장비 MAC 주소  학습 전이중  통신 충돌 도메인  분리 라우터  (Router) 3계층  장비 IP 주소  기반  경로  결정 브로드캐스트  도메인  분리 서로 다른  네트워크  간  통신 게이트웨이  (Gateway) 서로 다른  프로토콜  간  변환 네트워크  간  중개  역할</p>
<h2>3.6 라우팅</h2>
<p>라우팅이란 ? 패킷이  목적지까지  가는  최적의  경로를  결정하는  과정입니다 . 라우팅  테이블 목적지  네트워크 다음 홉  (Next Hop) 메트릭  (비용 ) 인터페이스 라우팅  프로토콜 내부 게이트웨이  프로토콜  (IGP) RIP: 거리  벡터 , 홉  수  기준 OSPF: 링크  상태 , 최단  경로  우선 EIGRP: 하이브리드 , 대역폭과  지연  고려 외부 게이트웨이  프로토콜  (EGP) BGP: 자율  시스템  간  라우팅 , 정책  기반</p>
<h2>3.7 DNS (Domain Name System)</h2>
<p>DNS란 ? 도메인  이름을  IP 주소로  변환하는  분산  데이터베이스  시스템입니다 . DNS 구조 루트 도메인: 최상위  (.) TLD (Top Level Domain): .com, .org, .net 등 2차 도메인: google, naver 등 서브 도메인: www, mail 등 DNS 레코드  타입 A: IPv4 주소 AAAA: IPv6 주소 CNAME: 별칭 MX: 메일  서버 NS: 네임  서버 PTR: 역방향  조회 TXT: 텍스트  정보 DNS 조회  과정</p>
<ol>
<li>로컬 DNS 서버에  질의</li>
<li>루트 DNS 서버  조회</li>
<li>TLD DNS 서버  조회</li>
<li>권한 DNS 서버  조회</li>
<li>IP 주소  반환</li>
<li>보안  기초</li>
</ol>
<h2>4.1 정보보안  3 요소</h2>
<p>기밀성  (Confidentiality) 인가된  사용자만  정보에  접근 암호화 , 접근  제어 무결성  (Integrity) 정보의  정확성과  완전성  보장 해시 함수 , 디지털  서명 가용성  (Availability) 필요할  때  정보에  접근  가능 이중화 , 백업</p>
<h2>4.2 암호화</h2>
<p>대칭키  암호화 암호화와  복호화에  같은  키  사용 빠른 처리  속도 키 관리의  어려움 예: AES, DES 비대칭키  암호화 공개키와  개인키  쌍  사용 키 교환  문제  해결 느린 처리  속도 예: RSA, ECC 해시 함수 임의 길이  데이터를  고정  길이로  변환 일방향  함수 무결성  검증에  사용 예: SHA-256, MD5</p>
<h2>4.3 네트워크  보안</h2>
<p>방화벽  (Firewall) 네트워크  접근  제어 패킷 필터링 상태 추적 애플리케이션  게이트웨이 IDS/IPS IDS: 침입  탐지  시스템 IPS: 침입  방지  시스템 시그니처  기반  / 행위  기반 VPN (Virtual Private Network) 공개 네트워크를  통한  안전한  통신 터널링 , 암호화 Site-to-Site, Remote Access</p>
<ol>
<li>시스템  성능  평가</li>
</ol>
<h2>5.1 성능  지표</h2>
<p>처리량  (Throughput) 단위 시간당  처리된  작업  수 TPS (Transaction Per Second) 응답 시간  (Response Time) 요청부터  응답까지  걸리는  시간 대기 시간  + 처리  시간 사용률  (Utilization) 자원이  사용된  시간  비율 CPU 사용률 , 메모리  사용률 처리능력  (Capacity) 시스템이  처리할  수  있는  최대  부하</p>
<h2>5.2 병목  현상</h2>
<p>병목 현상이란 ? 시스템에서  가장  느린  구성  요소가  전체  성능을  제한하는  현상입니다 . 병목점  식별 성능 모니터링 프로파일링 부하 테스트 해결 방법 하드웨어  업그레이드 알고리즘  최적화 아키텍처  개선 로드 밸런싱</p>
<h2>5.3 확장성</h2>
<p>수직 확장  (Scale Up) 단일 시스템의  성능  향상 CPU, 메모리  증설 한계가  명확함 수평 확장  (Scale Out) 시스템  수  증가 분산 처리 무제한  확장  가능 복잡성  증가</p>
</div>
</details>
